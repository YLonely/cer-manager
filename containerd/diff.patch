diff --git a/.gitignore b/.gitignore
index 73ba2c685..c7b98243a 100644
--- a/.gitignore
+++ b/.gitignore
@@ -8,3 +8,5 @@ releases/*.tar.gz
 releases/*.tar.gz.sha256sum
 _output/
 .vagrant/
+.vscode
+.gitignore
diff --git a/api/next.pb.txt b/api/next.pb.txt
index e7dc63663..d53b01e94 100644
--- a/api/next.pb.txt
+++ b/api/next.pb.txt
@@ -23,6 +23,7 @@ file {
     java_outer_classname: "AnyProto"
     java_multiple_files: true
     go_package: "github.com/golang/protobuf/ptypes/any"
+    java_generate_equals_and_hash: true
     objc_class_prefix: "GPB"
     csharp_namespace: "Google.Protobuf.WellKnownTypes"
   }
@@ -471,6 +472,7 @@ file {
     java_outer_classname: "TimestampProto"
     java_multiple_files: true
     go_package: "github.com/golang/protobuf/ptypes/timestamp"
+    java_generate_equals_and_hash: true
     cc_enable_arenas: true
     objc_class_prefix: "GPB"
     csharp_namespace: "Google.Protobuf.WellKnownTypes"
@@ -816,6 +818,7 @@ file {
     java_outer_classname: "EmptyProto"
     java_multiple_files: true
     go_package: "github.com/golang/protobuf/ptypes/empty"
+    java_generate_equals_and_hash: true
     cc_enable_arenas: true
     objc_class_prefix: "GPB"
     csharp_namespace: "Google.Protobuf.WellKnownTypes"
@@ -839,8 +842,7 @@ file {
     java_package: "com.google.protobuf"
     java_outer_classname: "FieldMaskProto"
     java_multiple_files: true
-    go_package: "google.golang.org/genproto/protobuf/field_mask;field_mask"
-    cc_enable_arenas: true
+    java_generate_equals_and_hash: true
     objc_class_prefix: "GPB"
     csharp_namespace: "Google.Protobuf.WellKnownTypes"
   }
@@ -4188,6 +4190,13 @@ file {
       type_name: ".google.protobuf.Any"
       json_name: "options"
     }
+    field {
+      name: "compress_checkpoint"
+      number: 4
+      label: LABEL_OPTIONAL
+      type: TYPE_BOOL
+      json_name: "compressCheckpoint"
+    }
   }
   message_type {
     name: "CheckpointTaskResponse"
diff --git a/api/services/tasks/v1/tasks.pb.go b/api/services/tasks/v1/tasks.pb.go
index 5ac5af11b..ddf2a6c9b 100644
--- a/api/services/tasks/v1/tasks.pb.go
+++ b/api/services/tasks/v1/tasks.pb.go
@@ -857,6 +857,7 @@ type CheckpointTaskRequest struct {
 	ContainerID          string                                     `protobuf:"bytes,1,opt,name=container_id,json=containerId,proto3" json:"container_id,omitempty"`
 	ParentCheckpoint     github_com_opencontainers_go_digest.Digest `protobuf:"bytes,2,opt,name=parent_checkpoint,json=parentCheckpoint,proto3,customtype=github.com/opencontainers/go-digest.Digest" json:"parent_checkpoint"`
 	Options              *types1.Any                                `protobuf:"bytes,3,opt,name=options,proto3" json:"options,omitempty"`
+	CompressCheckpoint   bool                                       `protobuf:"varint,4,opt,name=compress_checkpoint,json=compressCheckpoint,proto3" json:"compress_checkpoint,omitempty"`
 	XXX_NoUnkeyedLiteral struct{}                                   `json:"-"`
 	XXX_unrecognized     []byte                                     `json:"-"`
 	XXX_sizecache        int32                                      `json:"-"`
@@ -1166,90 +1167,91 @@ func init() {
 }
 
 var fileDescriptor_310e7127b8a26f14 = []byte{
-	// 1318 bytes of a gzipped FileDescriptorProto
-	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x58, 0x4b, 0x6f, 0x1b, 0x45,
-	0x1c, 0xef, 0xfa, 0xed, 0xbf, 0x93, 0x36, 0x59, 0xd2, 0x60, 0x96, 0x2a, 0x0e, 0xcb, 0xc5, 0x04,
-	0xba, 0x4b, 0x5d, 0x54, 0x21, 0x5a, 0x21, 0x35, 0x0f, 0x22, 0x0b, 0xaa, 0xa6, 0xdb, 0x02, 0x55,
-	0x25, 0x14, 0xb6, 0xbb, 0x13, 0x67, 0x14, 0x7b, 0x67, 0xbb, 0x33, 0x4e, 0x1b, 0x38, 0xc0, 0x47,
-	0xe8, 0x95, 0x0b, 0x9f, 0x27, 0x47, 0x8e, 0x08, 0x55, 0x81, 0xfa, 0x5b, 0x70, 0x43, 0xf3, 0xd8,
-	0xcd, 0xc6, 0x8e, 0xbd, 0x4e, 0xd3, 0x70, 0x69, 0x67, 0x66, 0xff, 0xaf, 0xf9, 0xcd, 0xff, 0xf1,
-	0x73, 0x60, 0xb5, 0x83, 0xd9, 0x6e, 0xff, 0xa9, 0xe5, 0x91, 0x9e, 0xed, 0x91, 0x80, 0xb9, 0x38,
-	0x40, 0x91, 0x9f, 0x5e, 0xba, 0x21, 0xb6, 0x29, 0x8a, 0xf6, 0xb1, 0x87, 0xa8, 0xcd, 0x5c, 0xba,
-	0x47, 0xed, 0xfd, 0x1b, 0x72, 0x61, 0x85, 0x11, 0x61, 0x44, 0xbf, 0x76, 0x2c, 0x6d, 0xc5, 0x92,
-	0x96, 0x14, 0xd8, 0xbf, 0x61, 0xbc, 0xdf, 0x21, 0xa4, 0xd3, 0x45, 0xb6, 0x90, 0x7d, 0xda, 0xdf,
-	0xb1, 0x51, 0x2f, 0x64, 0x07, 0x52, 0xd5, 0x78, 0x6f, 0xf8, 0xa3, 0x1b, 0xc4, 0x9f, 0x16, 0x3a,
-	0xa4, 0x43, 0xc4, 0xd2, 0xe6, 0x2b, 0x75, 0x7a, 0x6b, 0xaa, 0x78, 0xd9, 0x41, 0x88, 0xa8, 0xdd,
-	0x23, 0xfd, 0x80, 0x29, 0xbd, 0xcf, 0xcf, 0xa2, 0x87, 0x58, 0x84, 0x3d, 0x75, 0x3b, 0xe3, 0xf6,
-	0x19, 0x34, 0x7d, 0x44, 0xbd, 0x08, 0x87, 0x8c, 0x44, 0x4a, 0xf9, 0x8b, 0x33, 0x28, 0x73, 0xc4,
-	0xc4, 0x3f, 0x4a, 0xb7, 0x31, 0x8c, 0x0d, 0xc3, 0x3d, 0x44, 0x99, 0xdb, 0x0b, 0xa5, 0x80, 0x79,
-	0x98, 0x83, 0xf9, 0xb5, 0x08, 0xb9, 0x0c, 0x3d, 0x72, 0xe9, 0x9e, 0x83, 0x9e, 0xf5, 0x11, 0x65,
-	0x7a, 0x0b, 0x66, 0x12, 0xf3, 0xdb, 0xd8, 0xaf, 0x6b, 0xcb, 0x5a, 0xb3, 0xba, 0x7a, 0x65, 0x70,
-	0xd4, 0xa8, 0xad, 0xc5, 0xe7, 0xed, 0x75, 0xa7, 0x96, 0x08, 0xb5, 0x7d, 0xdd, 0x86, 0x52, 0x44,
-	0x08, 0xdb, 0xa1, 0xf5, 0xfc, 0x72, 0xbe, 0x59, 0x6b, 0xbd, 0x6b, 0xa5, 0x9e, 0x54, 0x44, 0x67,
-	0xdd, 0xe3, 0x60, 0x3a, 0x4a, 0x4c, 0x5f, 0x80, 0x22, 0x65, 0x3e, 0x0e, 0xea, 0x05, 0x6e, 0xdd,
-	0x91, 0x1b, 0x7d, 0x11, 0x4a, 0x94, 0xf9, 0xa4, 0xcf, 0xea, 0x45, 0x71, 0xac, 0x76, 0xea, 0x1c,
-	0x45, 0x51, 0xbd, 0x94, 0x9c, 0xa3, 0x28, 0xd2, 0x0d, 0xa8, 0x30, 0x14, 0xf5, 0x70, 0xe0, 0x76,
-	0xeb, 0xe5, 0x65, 0xad, 0x59, 0x71, 0x92, 0xbd, 0x7e, 0x07, 0xc0, 0xdb, 0x45, 0xde, 0x5e, 0x48,
-	0x70, 0xc0, 0xea, 0x95, 0x65, 0xad, 0x59, 0x6b, 0x5d, 0x1b, 0x0d, 0x6b, 0x3d, 0x41, 0xdc, 0x49,
-	0xc9, 0xeb, 0x16, 0x94, 0x49, 0xc8, 0x30, 0x09, 0x68, 0xbd, 0x2a, 0x54, 0x17, 0x2c, 0x89, 0xa6,
-	0x15, 0xa3, 0x69, 0xdd, 0x0d, 0x0e, 0x9c, 0x58, 0xc8, 0x7c, 0x02, 0x7a, 0x1a, 0x49, 0x1a, 0x92,
-	0x80, 0xa2, 0x37, 0x82, 0x72, 0x0e, 0xf2, 0x21, 0xf6, 0xeb, 0xb9, 0x65, 0xad, 0x39, 0xeb, 0xf0,
-	0xa5, 0xd9, 0x81, 0x99, 0x87, 0xcc, 0x8d, 0xd8, 0x79, 0x1e, 0xe8, 0x43, 0x28, 0xa3, 0x17, 0xc8,
-	0xdb, 0x56, 0x96, 0xab, 0xab, 0x30, 0x38, 0x6a, 0x94, 0x36, 0x5e, 0x20, 0xaf, 0xbd, 0xee, 0x94,
-	0xf8, 0xa7, 0xb6, 0x6f, 0x7e, 0x00, 0xb3, 0xca, 0x91, 0x8a, 0x5f, 0xc5, 0xa2, 0x1d, 0xc7, 0xb2,
-	0x09, 0xf3, 0xeb, 0xa8, 0x8b, 0xce, 0x9d, 0x31, 0xe6, 0xef, 0x1a, 0x5c, 0x96, 0x96, 0x12, 0x6f,
-	0x8b, 0x90, 0x4b, 0x94, 0x4b, 0x83, 0xa3, 0x46, 0xae, 0xbd, 0xee, 0xe4, 0xf0, 0x29, 0x88, 0xe8,
-	0x0d, 0xa8, 0xa1, 0x17, 0x98, 0x6d, 0x53, 0xe6, 0xb2, 0x3e, 0xcf, 0x39, 0xfe, 0x05, 0xf8, 0xd1,
-	0x43, 0x71, 0xa2, 0xdf, 0x85, 0x2a, 0xdf, 0x21, 0x7f, 0xdb, 0x65, 0x22, 0xc5, 0x6a, 0x2d, 0x63,
-	0xe4, 0x01, 0x1f, 0xc5, 0xe5, 0xb0, 0x5a, 0x39, 0x3c, 0x6a, 0x5c, 0x7a, 0xf9, 0x77, 0x43, 0x73,
-	0x2a, 0x52, 0xed, 0x2e, 0x33, 0x09, 0x2c, 0xc8, 0xf8, 0xb6, 0x22, 0xe2, 0x21, 0x4a, 0x2f, 0x1c,
-	0x7d, 0x04, 0xb0, 0x89, 0x2e, 0xfe, 0x91, 0x37, 0xa0, 0x26, 0xdc, 0x28, 0xd0, 0x6f, 0x41, 0x39,
-	0x94, 0x17, 0x14, 0x2e, 0x86, 0x6a, 0x64, 0xff, 0x86, 0x2a, 0x93, 0x18, 0x84, 0x58, 0xd8, 0x5c,
-	0x81, 0xb9, 0x6f, 0x30, 0x65, 0x3c, 0x0d, 0x12, 0x68, 0x16, 0xa1, 0xb4, 0x83, 0xbb, 0x0c, 0x45,
-	0x32, 0x5a, 0x47, 0xed, 0x78, 0xd2, 0xa4, 0x64, 0x93, 0xda, 0x28, 0x8a, 0x16, 0x5f, 0xd7, 0x44,
-	0xc7, 0x98, 0xec, 0x56, 0x8a, 0x9a, 0x2f, 0x35, 0xa8, 0x7d, 0x8d, 0xbb, 0xdd, 0x8b, 0x06, 0x49,
-	0x34, 0x1c, 0xdc, 0xe1, 0x6d, 0x45, 0xe6, 0x96, 0xda, 0xf1, 0x54, 0x74, 0xbb, 0x5d, 0x91, 0x51,
-	0x15, 0x87, 0x2f, 0xcd, 0x7f, 0x35, 0xd0, 0xb9, 0xf2, 0x5b, 0xc8, 0x92, 0xa4, 0x27, 0xe6, 0x4e,
-	0xef, 0x89, 0xf9, 0x31, 0x3d, 0xb1, 0x30, 0xb6, 0x27, 0x16, 0x87, 0x7a, 0x62, 0x13, 0x0a, 0x34,
-	0x44, 0x9e, 0xe8, 0xa2, 0xe3, 0x5a, 0x9a, 0x90, 0x48, 0xa3, 0x54, 0x1e, 0x9b, 0x4a, 0x57, 0xe1,
-	0x9d, 0x13, 0x57, 0x97, 0x2f, 0x6b, 0xfe, 0xa6, 0xc1, 0x9c, 0x83, 0x28, 0xfe, 0x09, 0x6d, 0xb1,
-	0x83, 0x0b, 0x7f, 0xaa, 0x05, 0x28, 0x3e, 0xc7, 0x3e, 0xdb, 0x55, 0x2f, 0x25, 0x37, 0x1c, 0x9d,
-	0x5d, 0x84, 0x3b, 0xbb, 0xb2, 0xfa, 0x67, 0x1d, 0xb5, 0x33, 0x7f, 0x81, 0xcb, 0x6b, 0x5d, 0x42,
-	0x51, 0xfb, 0xfe, 0xff, 0x11, 0x98, 0x7c, 0xce, 0xbc, 0x78, 0x05, 0xb9, 0x31, 0xbf, 0x82, 0xb9,
-	0x2d, 0xb7, 0x4f, 0xcf, 0xdd, 0x3f, 0x37, 0x61, 0xde, 0x41, 0xb4, 0xdf, 0x3b, 0xb7, 0xa1, 0x0d,
-	0xb8, 0xc2, 0x8b, 0x73, 0x0b, 0xfb, 0xe7, 0x49, 0x5e, 0xd3, 0x91, 0xfd, 0x40, 0x9a, 0x51, 0x25,
-	0xfe, 0x25, 0x54, 0x55, 0xbb, 0x40, 0x71, 0x99, 0x2f, 0x4f, 0x2a, 0xf3, 0x76, 0xb0, 0x43, 0x9c,
-	0x63, 0x15, 0xf3, 0x95, 0x06, 0x57, 0xd7, 0x92, 0x99, 0x7c, 0x5e, 0x8e, 0xb2, 0x0d, 0xf3, 0xa1,
-	0x1b, 0xa1, 0x80, 0x6d, 0xa7, 0x78, 0x81, 0x7c, 0xbe, 0x16, 0xef, 0xff, 0x7f, 0x1d, 0x35, 0x56,
-	0x52, 0x6c, 0x8b, 0x84, 0x28, 0x48, 0xd4, 0xa9, 0xdd, 0x21, 0xd7, 0x7d, 0xdc, 0x41, 0x94, 0x59,
-	0xeb, 0xe2, 0x3f, 0x67, 0x4e, 0x1a, 0x5b, 0x3b, 0x95, 0x33, 0xe4, 0xa7, 0xe1, 0x0c, 0x8f, 0x61,
-	0x71, 0xf8, 0x76, 0x09, 0x70, 0xb5, 0x63, 0x26, 0x78, 0x6a, 0x87, 0x1c, 0x21, 0x2f, 0x69, 0x05,
-	0xf3, 0x67, 0x98, 0xff, 0x36, 0xf4, 0xdf, 0x02, 0xaf, 0x6b, 0x41, 0x35, 0x42, 0x94, 0xf4, 0x23,
-	0x0f, 0x51, 0x81, 0xd5, 0xb8, 0x4b, 0x1d, 0x8b, 0x99, 0x2b, 0x70, 0xf9, 0x9e, 0x24, 0xc0, 0xb1,
-	0xe7, 0x3a, 0x94, 0xe5, 0x24, 0x90, 0x57, 0xa9, 0x3a, 0xf1, 0x96, 0x27, 0x5f, 0x22, 0x9b, 0xcc,
-	0x85, 0xb2, 0xe2, 0xcf, 0xea, 0xde, 0xf5, 0x53, 0xb8, 0xa4, 0x10, 0x70, 0x62, 0x41, 0x73, 0x07,
-	0x6a, 0xdf, 0xbb, 0xf8, 0xe2, 0x67, 0x67, 0x04, 0x33, 0xd2, 0x8f, 0x8a, 0x75, 0x88, 0x87, 0x68,
-	0x93, 0x79, 0x48, 0xee, 0x4d, 0x78, 0x48, 0xeb, 0xd5, 0x0c, 0x14, 0xc5, 0xe4, 0xd4, 0xf7, 0xa0,
-	0x24, 0x39, 0xa6, 0x6e, 0x5b, 0x93, 0x7e, 0x31, 0x59, 0x23, 0x9c, 0xde, 0xf8, 0x74, 0x7a, 0x05,
-	0x75, 0xb5, 0x1f, 0xa1, 0x28, 0xb8, 0xa0, 0xbe, 0x32, 0x59, 0x35, 0xcd, 0x4c, 0x8d, 0x8f, 0xa7,
-	0x92, 0x55, 0x1e, 0x3a, 0x50, 0x92, 0x04, 0x2b, 0xeb, 0x3a, 0x23, 0x84, 0xd3, 0xf8, 0x64, 0x1a,
-	0x85, 0xc4, 0xd1, 0x33, 0x98, 0x3d, 0xc1, 0xe4, 0xf4, 0xd6, 0x34, 0xea, 0x27, 0x07, 0xfa, 0x19,
-	0x5d, 0x3e, 0x81, 0xfc, 0x26, 0x62, 0x7a, 0x73, 0xb2, 0xd2, 0x31, 0xdd, 0x33, 0x3e, 0x9a, 0x42,
-	0x32, 0xc1, 0xad, 0xc0, 0x3b, 0xad, 0x6e, 0x4d, 0x56, 0x19, 0x66, 0x67, 0x86, 0x3d, 0xb5, 0xbc,
-	0x72, 0xd4, 0x86, 0x02, 0x27, 0x5b, 0x7a, 0x46, 0x6c, 0x29, 0x42, 0x66, 0x2c, 0x8e, 0x24, 0xf7,
-	0x06, 0xff, 0xb1, 0xae, 0x6f, 0x41, 0x81, 0x97, 0x92, 0x9e, 0x91, 0x87, 0xa3, 0x44, 0x6a, 0xac,
-	0xc5, 0x87, 0x50, 0x4d, 0x38, 0x46, 0x16, 0x14, 0xc3, 0x64, 0x64, 0xac, 0xd1, 0xfb, 0x50, 0x56,
-	0xec, 0x40, 0xcf, 0x78, 0xef, 0x93, 0x24, 0x62, 0x82, 0xc1, 0xa2, 0x98, 0xf6, 0x59, 0x11, 0x0e,
-	0x53, 0x82, 0xb1, 0x06, 0x1f, 0x40, 0x49, 0x8e, 0xfd, 0xac, 0xa2, 0x19, 0x21, 0x07, 0x63, 0x4d,
-	0x62, 0xa8, 0xc4, 0x93, 0x5b, 0xbf, 0x9e, 0x9d, 0x23, 0x29, 0xa2, 0x60, 0x58, 0xd3, 0x8a, 0xab,
-	0x8c, 0x7a, 0x0e, 0x90, 0x9a, 0x97, 0x37, 0x33, 0x20, 0x3e, 0x6d, 0xf2, 0x1b, 0x9f, 0x9d, 0x4d,
-	0x49, 0x39, 0x7e, 0x00, 0x25, 0x39, 0x10, 0xb3, 0x60, 0x1b, 0x19, 0x9b, 0x63, 0x61, 0xdb, 0x81,
-	0xb2, 0x1a, 0x5d, 0x59, 0xb9, 0x72, 0x72, 0x1a, 0x1a, 0xd7, 0xa7, 0x94, 0x56, 0xa1, 0xff, 0x00,
-	0x05, 0x3e, 0x73, 0xb2, 0xaa, 0x30, 0x35, 0xff, 0x8c, 0x95, 0x69, 0x44, 0xa5, 0xf9, 0xd5, 0xef,
-	0x0e, 0x5f, 0x2f, 0x5d, 0xfa, 0xf3, 0xf5, 0xd2, 0xa5, 0x5f, 0x07, 0x4b, 0xda, 0xe1, 0x60, 0x49,
-	0xfb, 0x63, 0xb0, 0xa4, 0xfd, 0x33, 0x58, 0xd2, 0x9e, 0xdc, 0x79, 0xb3, 0xbf, 0xec, 0xdd, 0x16,
-	0x8b, 0xc7, 0xb9, 0xa7, 0x25, 0x01, 0xd8, 0xcd, 0xff, 0x02, 0x00, 0x00, 0xff, 0xff, 0x85, 0xa2,
-	0x4f, 0xd1, 0x22, 0x14, 0x00, 0x00,
+	// 1339 bytes of a gzipped FileDescriptorProto
+	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x58, 0x5b, 0x6f, 0x1b, 0x45,
+	0x1b, 0xee, 0xfa, 0xec, 0xd7, 0x49, 0x9b, 0x6c, 0xd3, 0x7c, 0xfe, 0x96, 0x2a, 0x0e, 0xcb, 0x8d,
+	0x09, 0x74, 0x97, 0xba, 0xa8, 0x42, 0xb4, 0x42, 0x6a, 0x0e, 0x44, 0x16, 0x54, 0x4d, 0xb7, 0x05,
+	0xaa, 0x4a, 0x28, 0x6c, 0x77, 0x27, 0xce, 0x28, 0xf6, 0xce, 0x76, 0x67, 0x9c, 0x36, 0x70, 0x01,
+	0x7f, 0x00, 0xa9, 0xb7, 0xdc, 0xf0, 0x7b, 0x72, 0xc9, 0x25, 0x42, 0x28, 0x50, 0xff, 0x0b, 0xee,
+	0xd0, 0x1c, 0x76, 0xbd, 0xb1, 0xe3, 0x43, 0xea, 0x86, 0x9b, 0x76, 0x66, 0xf6, 0x3d, 0xcd, 0x33,
+	0xef, 0xe1, 0x71, 0x60, 0xbd, 0x85, 0xd9, 0x7e, 0xf7, 0x99, 0xe5, 0x91, 0x8e, 0xed, 0x91, 0x80,
+	0xb9, 0x38, 0x40, 0x91, 0x9f, 0x5e, 0xba, 0x21, 0xb6, 0x29, 0x8a, 0x0e, 0xb1, 0x87, 0xa8, 0xcd,
+	0x5c, 0x7a, 0x40, 0xed, 0xc3, 0x9b, 0x72, 0x61, 0x85, 0x11, 0x61, 0x44, 0xbf, 0xde, 0x97, 0xb6,
+	0x62, 0x49, 0x4b, 0x0a, 0x1c, 0xde, 0x34, 0xde, 0x69, 0x11, 0xd2, 0x6a, 0x23, 0x5b, 0xc8, 0x3e,
+	0xeb, 0xee, 0xd9, 0xa8, 0x13, 0xb2, 0x23, 0xa9, 0x6a, 0xfc, 0x7f, 0xf0, 0xa3, 0x1b, 0xc4, 0x9f,
+	0x96, 0x5a, 0xa4, 0x45, 0xc4, 0xd2, 0xe6, 0x2b, 0x75, 0x7a, 0x7b, 0xaa, 0x78, 0xd9, 0x51, 0x88,
+	0xa8, 0xdd, 0x21, 0xdd, 0x80, 0x29, 0xbd, 0x4f, 0xce, 0xa3, 0x87, 0x58, 0x84, 0x3d, 0x75, 0x3b,
+	0xe3, 0xce, 0x39, 0x34, 0x7d, 0x44, 0xbd, 0x08, 0x87, 0x8c, 0x44, 0x4a, 0xf9, 0xd3, 0x73, 0x28,
+	0x73, 0xc4, 0xc4, 0x3f, 0x4a, 0xb7, 0x36, 0x88, 0x0d, 0xc3, 0x1d, 0x44, 0x99, 0xdb, 0x09, 0xa5,
+	0x80, 0x79, 0x9c, 0x81, 0xc5, 0x8d, 0x08, 0xb9, 0x0c, 0x3d, 0x76, 0xe9, 0x81, 0x83, 0x9e, 0x77,
+	0x11, 0x65, 0x7a, 0x03, 0xe6, 0x12, 0xf3, 0xbb, 0xd8, 0xaf, 0x6a, 0xab, 0x5a, 0xbd, 0xbc, 0x7e,
+	0xa5, 0x77, 0x52, 0xab, 0x6c, 0xc4, 0xe7, 0xcd, 0x4d, 0xa7, 0x92, 0x08, 0x35, 0x7d, 0xdd, 0x86,
+	0x42, 0x44, 0x08, 0xdb, 0xa3, 0xd5, 0xec, 0x6a, 0xb6, 0x5e, 0x69, 0xfc, 0xcf, 0x4a, 0x3d, 0xa9,
+	0x88, 0xce, 0xba, 0xcf, 0xc1, 0x74, 0x94, 0x98, 0xbe, 0x04, 0x79, 0xca, 0x7c, 0x1c, 0x54, 0x73,
+	0xdc, 0xba, 0x23, 0x37, 0xfa, 0x32, 0x14, 0x28, 0xf3, 0x49, 0x97, 0x55, 0xf3, 0xe2, 0x58, 0xed,
+	0xd4, 0x39, 0x8a, 0xa2, 0x6a, 0x21, 0x39, 0x47, 0x51, 0xa4, 0x1b, 0x50, 0x62, 0x28, 0xea, 0xe0,
+	0xc0, 0x6d, 0x57, 0x8b, 0xab, 0x5a, 0xbd, 0xe4, 0x24, 0x7b, 0xfd, 0x2e, 0x80, 0xb7, 0x8f, 0xbc,
+	0x83, 0x90, 0xe0, 0x80, 0x55, 0x4b, 0xab, 0x5a, 0xbd, 0xd2, 0xb8, 0x3e, 0x1c, 0xd6, 0x66, 0x82,
+	0xb8, 0x93, 0x92, 0xd7, 0x2d, 0x28, 0x92, 0x90, 0x61, 0x12, 0xd0, 0x6a, 0x59, 0xa8, 0x2e, 0x59,
+	0x12, 0x4d, 0x2b, 0x46, 0xd3, 0xba, 0x17, 0x1c, 0x39, 0xb1, 0x90, 0xf9, 0x14, 0xf4, 0x34, 0x92,
+	0x34, 0x24, 0x01, 0x45, 0x6f, 0x04, 0xe5, 0x02, 0x64, 0x43, 0xec, 0x57, 0x33, 0xab, 0x5a, 0x7d,
+	0xde, 0xe1, 0x4b, 0xb3, 0x05, 0x73, 0x8f, 0x98, 0x1b, 0xb1, 0x59, 0x1e, 0xe8, 0x3d, 0x28, 0xa2,
+	0x97, 0xc8, 0xdb, 0x55, 0x96, 0xcb, 0xeb, 0xd0, 0x3b, 0xa9, 0x15, 0xb6, 0x5e, 0x22, 0xaf, 0xb9,
+	0xe9, 0x14, 0xf8, 0xa7, 0xa6, 0x6f, 0xbe, 0x0b, 0xf3, 0xca, 0x91, 0x8a, 0x5f, 0xc5, 0xa2, 0xf5,
+	0x63, 0xd9, 0x86, 0xc5, 0x4d, 0xd4, 0x46, 0x33, 0x67, 0x8c, 0xf9, 0xab, 0x06, 0x97, 0xa5, 0xa5,
+	0xc4, 0xdb, 0x32, 0x64, 0x12, 0xe5, 0x42, 0xef, 0xa4, 0x96, 0x69, 0x6e, 0x3a, 0x19, 0x7c, 0x06,
+	0x22, 0x7a, 0x0d, 0x2a, 0xe8, 0x25, 0x66, 0xbb, 0x94, 0xb9, 0xac, 0xcb, 0x73, 0x8e, 0x7f, 0x01,
+	0x7e, 0xf4, 0x48, 0x9c, 0xe8, 0xf7, 0xa0, 0xcc, 0x77, 0xc8, 0xdf, 0x75, 0x99, 0x48, 0xb1, 0x4a,
+	0xc3, 0x18, 0x7a, 0xc0, 0xc7, 0x71, 0x39, 0xac, 0x97, 0x8e, 0x4f, 0x6a, 0x97, 0x5e, 0xfd, 0x55,
+	0xd3, 0x9c, 0x92, 0x54, 0xbb, 0xc7, 0x4c, 0x02, 0x4b, 0x32, 0xbe, 0x9d, 0x88, 0x78, 0x88, 0xd2,
+	0x0b, 0x47, 0x1f, 0x01, 0x6c, 0xa3, 0x8b, 0x7f, 0xe4, 0x2d, 0xa8, 0x08, 0x37, 0x0a, 0xf4, 0xdb,
+	0x50, 0x0c, 0xe5, 0x05, 0x85, 0x8b, 0x81, 0x1a, 0x39, 0xbc, 0xa9, 0xca, 0x24, 0x06, 0x21, 0x16,
+	0x36, 0xd7, 0x60, 0xe1, 0x4b, 0x4c, 0x19, 0x4f, 0x83, 0x04, 0x9a, 0x65, 0x28, 0xec, 0xe1, 0x36,
+	0x43, 0x91, 0x8c, 0xd6, 0x51, 0x3b, 0x9e, 0x34, 0x29, 0xd9, 0xa4, 0x36, 0xf2, 0xa2, 0xc5, 0x57,
+	0x35, 0xd1, 0x31, 0xc6, 0xbb, 0x95, 0xa2, 0xe6, 0x2b, 0x0d, 0x2a, 0x5f, 0xe0, 0x76, 0xfb, 0xa2,
+	0x41, 0x12, 0x0d, 0x07, 0xb7, 0x78, 0x5b, 0x91, 0xb9, 0xa5, 0x76, 0x3c, 0x15, 0xdd, 0x76, 0x5b,
+	0x64, 0x54, 0xc9, 0xe1, 0x4b, 0xf3, 0x1f, 0x0d, 0x74, 0xae, 0xfc, 0x16, 0xb2, 0x24, 0xe9, 0x89,
+	0x99, 0xb3, 0x7b, 0x62, 0x76, 0x44, 0x4f, 0xcc, 0x8d, 0xec, 0x89, 0xf9, 0x81, 0x9e, 0x58, 0x87,
+	0x1c, 0x0d, 0x91, 0x27, 0xba, 0xe8, 0xa8, 0x96, 0x26, 0x24, 0xd2, 0x28, 0x15, 0x47, 0xa6, 0xd2,
+	0x35, 0xb8, 0x7a, 0xea, 0xea, 0xf2, 0x65, 0xcd, 0x5f, 0x34, 0x58, 0x70, 0x10, 0xc5, 0xdf, 0xa3,
+	0x1d, 0x76, 0x74, 0xe1, 0x4f, 0xb5, 0x04, 0xf9, 0x17, 0xd8, 0x67, 0xfb, 0xea, 0xa5, 0xe4, 0x86,
+	0xa3, 0xb3, 0x8f, 0x70, 0x6b, 0x5f, 0x56, 0xff, 0xbc, 0xa3, 0x76, 0xe6, 0x8f, 0x70, 0x79, 0xa3,
+	0x4d, 0x28, 0x6a, 0x3e, 0xf8, 0x2f, 0x02, 0x93, 0xcf, 0x99, 0x15, 0xaf, 0x20, 0x37, 0xe6, 0xe7,
+	0xb0, 0xb0, 0xe3, 0x76, 0xe9, 0xcc, 0xfd, 0x73, 0x1b, 0x16, 0x1d, 0x44, 0xbb, 0x9d, 0x99, 0x0d,
+	0x6d, 0xc1, 0x15, 0x5e, 0x9c, 0x3b, 0xd8, 0x9f, 0x25, 0x79, 0x4d, 0x47, 0xf6, 0x03, 0x69, 0x46,
+	0x95, 0xf8, 0x67, 0x50, 0x56, 0xed, 0x02, 0xc5, 0x65, 0xbe, 0x3a, 0xae, 0xcc, 0x9b, 0xc1, 0x1e,
+	0x71, 0xfa, 0x2a, 0xe6, 0xcf, 0x19, 0xb8, 0xb6, 0x91, 0xcc, 0xe4, 0x59, 0x39, 0xca, 0x2e, 0x2c,
+	0x86, 0x6e, 0x84, 0x02, 0xb6, 0x9b, 0xe2, 0x05, 0xf2, 0xf9, 0x1a, 0xbc, 0xff, 0xff, 0x71, 0x52,
+	0x5b, 0x4b, 0xb1, 0x2d, 0x12, 0xa2, 0x20, 0x51, 0xa7, 0x76, 0x8b, 0xdc, 0xf0, 0x71, 0x0b, 0x51,
+	0x66, 0x6d, 0x8a, 0xff, 0x9c, 0x05, 0x69, 0x6c, 0xe3, 0x4c, 0xce, 0x90, 0x9d, 0x82, 0x33, 0xe8,
+	0x36, 0x5c, 0xf5, 0x48, 0x27, 0x8c, 0x10, 0xa5, 0xe9, 0x90, 0x64, 0x73, 0xd1, 0xe3, 0x4f, 0x7d,
+	0x07, 0xe6, 0x13, 0x58, 0x1e, 0x84, 0x23, 0x41, 0xba, 0xd2, 0xa7, 0x8e, 0x67, 0xb6, 0xd4, 0x21,
+	0xb6, 0x93, 0x56, 0x30, 0x7f, 0x80, 0xc5, 0xaf, 0x42, 0xff, 0x2d, 0x10, 0xc1, 0x06, 0x94, 0x23,
+	0x44, 0x49, 0x37, 0xf2, 0x10, 0x15, 0xe0, 0x8e, 0x42, 0xa1, 0x2f, 0x66, 0xae, 0xc1, 0xe5, 0xfb,
+	0x92, 0x31, 0xc7, 0x9e, 0xab, 0x50, 0x94, 0xa3, 0x43, 0x5e, 0xa5, 0xec, 0xc4, 0x5b, 0x9e, 0xad,
+	0x89, 0x6c, 0x32, 0x48, 0x8a, 0x8a, 0x70, 0xab, 0x7b, 0x57, 0xcf, 0x20, 0x9f, 0x42, 0xc0, 0x89,
+	0x05, 0xcd, 0x3d, 0xa8, 0x7c, 0xe3, 0xe2, 0x8b, 0x1f, 0xb6, 0x11, 0xcc, 0x49, 0x3f, 0x2a, 0xd6,
+	0x01, 0xe2, 0xa2, 0x8d, 0x27, 0x2e, 0x99, 0x37, 0x21, 0x2e, 0x8d, 0x3f, 0xe7, 0x20, 0x2f, 0x46,
+	0xad, 0x7e, 0x00, 0x05, 0x49, 0x4a, 0x75, 0xdb, 0x1a, 0xf7, 0x13, 0xcb, 0x1a, 0xfa, 0x11, 0x60,
+	0x7c, 0x34, 0xbd, 0x82, 0xba, 0xda, 0x77, 0x90, 0x17, 0xe4, 0x51, 0x5f, 0x1b, 0xaf, 0x9a, 0xa6,
+	0xb2, 0xc6, 0x07, 0x53, 0xc9, 0x2a, 0x0f, 0x2d, 0x28, 0x48, 0x46, 0x36, 0xe9, 0x3a, 0x43, 0x0c,
+	0xd5, 0xf8, 0x70, 0x1a, 0x85, 0xc4, 0xd1, 0x73, 0x98, 0x3f, 0x45, 0xfd, 0xf4, 0xc6, 0x34, 0xea,
+	0xa7, 0x19, 0xc0, 0x39, 0x5d, 0x3e, 0x85, 0xec, 0x36, 0x62, 0x7a, 0x7d, 0xbc, 0x52, 0x9f, 0x1f,
+	0x1a, 0xef, 0x4f, 0x21, 0x99, 0xe0, 0x96, 0xe3, 0xad, 0x59, 0xb7, 0xc6, 0xab, 0x0c, 0xd2, 0x39,
+	0xc3, 0x9e, 0x5a, 0x5e, 0x39, 0x6a, 0x42, 0x8e, 0xb3, 0x33, 0x7d, 0x42, 0x6c, 0x29, 0x06, 0x67,
+	0x2c, 0x0f, 0x25, 0xf7, 0x16, 0xff, 0x75, 0xaf, 0xef, 0x40, 0x8e, 0x97, 0x92, 0x3e, 0x21, 0x0f,
+	0x87, 0x99, 0xd7, 0x48, 0x8b, 0x8f, 0xa0, 0x9c, 0x90, 0x92, 0x49, 0x50, 0x0c, 0xb2, 0x97, 0x91,
+	0x46, 0x1f, 0x40, 0x51, 0xd1, 0x09, 0x7d, 0xc2, 0x7b, 0x9f, 0x66, 0x1d, 0x63, 0x0c, 0xe6, 0x05,
+	0x3d, 0x98, 0x14, 0xe1, 0x20, 0x87, 0x18, 0x69, 0xf0, 0x21, 0x14, 0x24, 0x4f, 0x98, 0x54, 0x34,
+	0x43, 0x6c, 0x62, 0xa4, 0x49, 0x0c, 0xa5, 0x78, 0xd4, 0xeb, 0x37, 0x26, 0xe7, 0x48, 0x8a, 0x59,
+	0x18, 0xd6, 0xb4, 0xe2, 0x2a, 0xa3, 0x5e, 0x00, 0xa4, 0x06, 0xec, 0xad, 0x09, 0x10, 0x9f, 0x45,
+	0x15, 0x8c, 0x8f, 0xcf, 0xa7, 0xa4, 0x1c, 0x3f, 0x84, 0x82, 0x1c, 0x88, 0x93, 0x60, 0x1b, 0x1a,
+	0x9b, 0x23, 0x61, 0xdb, 0x83, 0xa2, 0x1a, 0x5d, 0x93, 0x72, 0xe5, 0xf4, 0x34, 0x34, 0x6e, 0x4c,
+	0x29, 0xad, 0x42, 0xff, 0x16, 0x72, 0x7c, 0xe6, 0x4c, 0xaa, 0xc2, 0xd4, 0xfc, 0x33, 0xd6, 0xa6,
+	0x11, 0x95, 0xe6, 0xd7, 0xbf, 0x3e, 0x7e, 0xbd, 0x72, 0xe9, 0xf7, 0xd7, 0x2b, 0x97, 0x7e, 0xea,
+	0xad, 0x68, 0xc7, 0xbd, 0x15, 0xed, 0xb7, 0xde, 0x8a, 0xf6, 0x77, 0x6f, 0x45, 0x7b, 0x7a, 0xf7,
+	0xcd, 0xfe, 0x14, 0x78, 0x47, 0x2c, 0x9e, 0x64, 0x9e, 0x15, 0x04, 0x60, 0xb7, 0xfe, 0x0d, 0x00,
+	0x00, 0xff, 0xff, 0xe7, 0x1f, 0x82, 0x6d, 0x53, 0x14, 0x00, 0x00,
 }
 
 // Reference imports to suppress errors if they are not otherwise used.
@@ -2849,6 +2851,16 @@ func (m *CheckpointTaskRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
 		i -= len(m.XXX_unrecognized)
 		copy(dAtA[i:], m.XXX_unrecognized)
 	}
+	if m.CompressCheckpoint {
+		i--
+		if m.CompressCheckpoint {
+			dAtA[i] = 1
+		} else {
+			dAtA[i] = 0
+		}
+		i--
+		dAtA[i] = 0x20
+	}
 	if m.Options != nil {
 		{
 			size, err := m.Options.MarshalToSizedBuffer(dAtA[:i])
@@ -3573,6 +3585,9 @@ func (m *CheckpointTaskRequest) Size() (n int) {
 		l = m.Options.Size()
 		n += 1 + l + sovTasks(uint64(l))
 	}
+	if m.CompressCheckpoint {
+		n += 2
+	}
 	if m.XXX_unrecognized != nil {
 		n += len(m.XXX_unrecognized)
 	}
@@ -3966,6 +3981,7 @@ func (this *CheckpointTaskRequest) String() string {
 		`ContainerID:` + fmt.Sprintf("%v", this.ContainerID) + `,`,
 		`ParentCheckpoint:` + fmt.Sprintf("%v", this.ParentCheckpoint) + `,`,
 		`Options:` + strings.Replace(fmt.Sprintf("%v", this.Options), "Any", "types1.Any", 1) + `,`,
+		`CompressCheckpoint:` + fmt.Sprintf("%v", this.CompressCheckpoint) + `,`,
 		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
 		`}`,
 	}, "")
@@ -6655,6 +6671,26 @@ func (m *CheckpointTaskRequest) Unmarshal(dAtA []byte) error {
 				return err
 			}
 			iNdEx = postIndex
+		case 4:
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field CompressCheckpoint", wireType)
+			}
+			var v int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowTasks
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				v |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			m.CompressCheckpoint = bool(v != 0)
 		default:
 			iNdEx = preIndex
 			skippy, err := skipTasks(dAtA[iNdEx:])
diff --git a/api/services/tasks/v1/tasks.proto b/api/services/tasks/v1/tasks.proto
index 90793cbab..a32eb4d22 100644
--- a/api/services/tasks/v1/tasks.proto
+++ b/api/services/tasks/v1/tasks.proto
@@ -179,6 +179,7 @@ message CheckpointTaskRequest {
 	string container_id = 1;
 	string parent_checkpoint = 2 [(gogoproto.customtype) = "github.com/opencontainers/go-digest.Digest", (gogoproto.nullable) = false];
 	google.protobuf.Any options = 3;
+	bool compress_checkpoint = 4;
 }
 
 message CheckpointTaskResponse {
diff --git a/client.go b/client.go
index e72433c9b..5a71c4303 100644
--- a/client.go
+++ b/client.go
@@ -45,6 +45,7 @@ import (
 	"github.com/containerd/containerd/defaults"
 	"github.com/containerd/containerd/errdefs"
 	"github.com/containerd/containerd/events"
+	"github.com/containerd/containerd/external"
 	"github.com/containerd/containerd/images"
 	"github.com/containerd/containerd/leases"
 	leasesproxy "github.com/containerd/containerd/leases/proxy"
@@ -75,6 +76,7 @@ func init() {
 	typeurl.Register(&specs.Process{}, prefix, "opencontainers/runtime-spec", major, "Process")
 	typeurl.Register(&specs.LinuxResources{}, prefix, "opencontainers/runtime-spec", major, "LinuxResources")
 	typeurl.Register(&specs.WindowsResources{}, prefix, "opencontainers/runtime-spec", major, "WindowsResources")
+	typeurl.Register(&external.ResourcesInfo{}, prefix, "containerd/containerd", "ExternalResources")
 }
 
 // New returns a new containerd client that is connected to the containerd
@@ -209,6 +211,10 @@ type Client struct {
 	connector func() (*grpc.ClientConn, error)
 }
 
+func (c *Client) Namespace() string {
+	return c.defaultns
+}
+
 // Reconnect re-establishes the GRPC connection to the containerd daemon
 func (c *Client) Reconnect() error {
 	if c.connector == nil {
@@ -483,7 +489,7 @@ func (c *Client) ListImages(ctx context.Context, filters ...string) ([]Image, er
 }
 
 // Restore restores a container from a checkpoint
-func (c *Client) Restore(ctx context.Context, id string, checkpoint Image, opts ...RestoreOpts) (Container, error) {
+func (c *Client) Restore(ctx context.Context, id string, checkpoint Image, opts []RestoreOpts, containerOpts ...NewContainerOpts) (Container, error) {
 	store := c.ContentStore()
 	index, err := decodeIndex(ctx, store, checkpoint.Target())
 	if err != nil {
@@ -500,6 +506,7 @@ func (c *Client) Restore(ctx context.Context, id string, checkpoint Image, opts
 	for _, o := range opts {
 		copts = append(copts, o(ctx, id, c, checkpoint, index))
 	}
+	copts = append(copts, containerOpts...)
 
 	ctr, err := c.NewContainer(ctx, id, copts...)
 	if err != nil {
diff --git a/cmd/ctr/commands/client.go b/cmd/ctr/commands/client.go
index c6bdc390c..98eb746e7 100644
--- a/cmd/ctr/commands/client.go
+++ b/cmd/ctr/commands/client.go
@@ -48,7 +48,7 @@ func AppContext(context *cli.Context) (gocontext.Context, gocontext.CancelFunc)
 // NewClient returns a new containerd client
 func NewClient(context *cli.Context, opts ...containerd.ClientOpt) (*containerd.Client, gocontext.Context, gocontext.CancelFunc, error) {
 	timeoutOpt := containerd.WithTimeout(context.GlobalDuration("connect-timeout"))
-	opts = append(opts, timeoutOpt)
+	opts = append(opts, timeoutOpt, containerd.WithDefaultNamespace(context.GlobalString("namespace")))
 	client, err := containerd.New(context.GlobalString("address"), opts...)
 	if err != nil {
 		return nil, nil, nil, err
diff --git a/cmd/ctr/commands/containers/checkpoint.go b/cmd/ctr/commands/containers/checkpoint.go
index 53bf70b3c..981cc1749 100644
--- a/cmd/ctr/commands/containers/checkpoint.go
+++ b/cmd/ctr/commands/containers/checkpoint.go
@@ -43,6 +43,10 @@ var checkpointCommand = cli.Command{
 			Name:  "task",
 			Usage: "checkpoint container task",
 		},
+		cli.BoolFlag{
+			Name:  "compress-checkpoint",
+			Usage: "use stargz to compress checkpoint files",
+		},
 	},
 	Action: func(context *cli.Context) error {
 		id := context.Args().First()
@@ -69,7 +73,7 @@ var checkpointCommand = cli.Command{
 			opts = append(opts, containerd.WithCheckpointRW)
 		}
 		if context.Bool("task") {
-			opts = append(opts, containerd.WithCheckpointTask)
+			opts = append(opts, containerd.WithCheckpointTask(context.Bool("compress-checkpoint")))
 		}
 		container, err := client.LoadContainer(ctx, id)
 		if err != nil {
diff --git a/cmd/ctr/commands/containers/restore.go b/cmd/ctr/commands/containers/restore.go
index 85337b34d..86a638c16 100644
--- a/cmd/ctr/commands/containers/restore.go
+++ b/cmd/ctr/commands/containers/restore.go
@@ -17,10 +17,14 @@
 package containers
 
 import (
+	cmclient "github.com/YLonely/cer-manager/client"
 	"github.com/containerd/containerd"
 	"github.com/containerd/containerd/cio"
 	"github.com/containerd/containerd/cmd/ctr/commands"
 	"github.com/containerd/containerd/errdefs"
+	"github.com/containerd/containerd/external"
+	"github.com/containerd/containerd/oci"
+	"github.com/opencontainers/runtime-spec/specs-go"
 	"github.com/pkg/errors"
 	"github.com/urfave/cli"
 )
@@ -38,6 +42,14 @@ var restoreCommand = cli.Command{
 			Name:  "live",
 			Usage: "restore the runtime and memory data from the checkpoint",
 		},
+		cli.StringSliceFlag{
+			Name:  "external-ns",
+			Usage: "specifiy the type of the namespace {ipc|uts|mnt} that is dynamically chosen while restoring",
+		},
+		cli.BoolFlag{
+			Name:  "external-checkpoint",
+			Usage: "get the path of checkpoint files from the container external resources manager",
+		},
 	},
 	Action: func(context *cli.Context) error {
 		id := context.Args().First()
@@ -68,22 +80,64 @@ var restoreCommand = cli.Command{
 		}
 
 		opts := []containerd.RestoreOpts{
-			containerd.WithRestoreImage,
-			containerd.WithRestoreSpec,
 			containerd.WithRestoreRuntime,
 		}
+		copts := []containerd.NewContainerOpts{}
+		specOpts := []oci.SpecOpts{}
+		externalMountNamespace := false
+		externalResources := external.ResourcesInfo{
+			Namespaces: map[specs.LinuxNamespaceType]external.NamespaceInfo{},
+		}
+		if len(context.StringSlice("external-ns")) == 0 {
+			opts = append(opts, containerd.WithRestoreSpec)
+		} else {
+			cli, err := cmclient.Default()
+			if err != nil {
+				return err
+			}
+			defer cli.Close()
+			spec, err := containerd.ParseSpecFromCheckpoint(ctx, client.ContentStore(), checkpoint)
+			if err != nil {
+				return err
+			}
+			for _, ns := range context.StringSlice("external-ns") {
+				switch ns {
+				case "mnt":
+					externalMountNamespace = true
+					if err = handleExternalNamespace(cli, specs.MountNamespace, client, checkpoint, &specOpts, &externalResources); err != nil {
+						return err
+					}
+				case "ipc":
+					if err = handleExternalNamespace(cli, specs.IPCNamespace, client, checkpoint, &specOpts, &externalResources); err != nil {
+						return err
+					}
+				case "uts":
+					if err = handleExternalNamespace(cli, specs.UTSNamespace, client, checkpoint, &specOpts, &externalResources); err != nil {
+						return err
+					}
+				default:
+					return errors.New("invalid namespace type")
+				}
+			}
+			copts = append(copts, containerd.WithSpec(spec, specOpts...))
+		}
+		copts = append(copts, containerd.WithContainerExtension(external.ResourcesExtensionKey, &externalResources))
+
+		if !externalMountNamespace {
+			opts = append(opts, containerd.WithRestoreImage)
+		}
 		if context.Bool("rw") {
 			opts = append(opts, containerd.WithRestoreRW)
 		}
 
-		ctr, err := client.Restore(ctx, id, checkpoint, opts...)
+		ctr, err := client.Restore(ctx, id, checkpoint, opts, copts...)
 		if err != nil {
 			return err
 		}
 
 		topts := []containerd.NewTaskOpts{}
 		if context.Bool("live") {
-			topts = append(topts, containerd.WithTaskCheckpoint(checkpoint))
+			topts = append(topts, containerd.WithTaskCheckpoint(checkpoint, context.Bool("external-checkpoint")))
 		}
 
 		task, err := ctr.NewTask(ctx, cio.NewCreator(cio.WithStdio), topts...)
@@ -94,3 +148,22 @@ var restoreCommand = cli.Command{
 		return task.Start(ctx)
 	},
 }
+
+func handleExternalNamespace(cli *cmclient.Client, t specs.LinuxNamespaceType, client *containerd.Client, checkpoint containerd.Image, specOpts *[]oci.SpecOpts, externalResources *external.ResourcesInfo) error {
+	id, path, info, err := external.GetNamespace(cli, t, client.Namespace(), checkpoint.Name())
+	if err != nil {
+		return errors.Wrap(err, "failed to get external mount namespace")
+	}
+	*specOpts = append(*specOpts, oci.WithLinuxNamespace(
+		specs.LinuxNamespace{
+			Type: t,
+			Path: path,
+		},
+	))
+	externalResources.Namespaces[t] = external.NamespaceInfo{
+		ID:   id,
+		Info: info,
+		Path: path,
+	}
+	return nil
+}
diff --git a/cmd/ctr/commands/tasks/tasks_unix.go b/cmd/ctr/commands/tasks/tasks_unix.go
index 0ec6dc010..df9248b56 100644
--- a/cmd/ctr/commands/tasks/tasks_unix.go
+++ b/cmd/ctr/commands/tasks/tasks_unix.go
@@ -77,7 +77,7 @@ func NewTask(ctx gocontext.Context, client *containerd.Client, container contain
 		if err != nil {
 			return nil, err
 		}
-		opts = append(opts, containerd.WithTaskCheckpoint(im))
+		opts = append(opts, containerd.WithTaskCheckpoint(im, false))
 	}
 	var ioCreator cio.Creator
 	if con != nil {
diff --git a/container_checkpoint_opts.go b/container_checkpoint_opts.go
index 510863681..72bb9f36e 100644
--- a/container_checkpoint_opts.go
+++ b/container_checkpoint_opts.go
@@ -55,44 +55,47 @@ func WithCheckpointImage(ctx context.Context, client *Client, c *containers.Cont
 }
 
 // WithCheckpointTask includes the running task
-func WithCheckpointTask(ctx context.Context, client *Client, c *containers.Container, index *imagespec.Index, copts *options.CheckpointOptions) error {
-	any, err := typeurl.MarshalAny(copts)
-	if err != nil {
-		return nil
-	}
-	task, err := client.TaskService().Checkpoint(ctx, &tasks.CheckpointTaskRequest{
-		ContainerID: c.ID,
-		Options:     any,
-	})
-	if err != nil {
-		return err
-	}
-	for _, d := range task.Descriptors {
-		platformSpec := platforms.DefaultSpec()
-		index.Manifests = append(index.Manifests, imagespec.Descriptor{
-			MediaType:   d.MediaType,
-			Size:        d.Size_,
-			Digest:      d.Digest,
-			Platform:    &platformSpec,
-			Annotations: d.Annotations,
+func WithCheckpointTask(compressCheckpoint bool) CheckpointOpts {
+	return func(ctx context.Context, client *Client, c *containers.Container, index *imagespec.Index, copts *options.CheckpointOptions) error {
+		any, err := typeurl.MarshalAny(copts)
+		if err != nil {
+			return nil
+		}
+		task, err := client.TaskService().Checkpoint(ctx, &tasks.CheckpointTaskRequest{
+			ContainerID:        c.ID,
+			Options:            any,
+			CompressCheckpoint: compressCheckpoint,
 		})
+		if err != nil {
+			return err
+		}
+		for _, d := range task.Descriptors {
+			platformSpec := platforms.DefaultSpec()
+			index.Manifests = append(index.Manifests, imagespec.Descriptor{
+				MediaType:   d.MediaType,
+				Size:        d.Size_,
+				Digest:      d.Digest,
+				Platform:    &platformSpec,
+				Annotations: d.Annotations,
+			})
+		}
+		// save copts
+		data, err := any.Marshal()
+		if err != nil {
+			return err
+		}
+		r := bytes.NewReader(data)
+		desc, err := writeContent(ctx, client.ContentStore(), images.MediaTypeContainerd1CheckpointOptions, c.ID+"-checkpoint-options", r)
+		if err != nil {
+			return err
+		}
+		desc.Platform = &imagespec.Platform{
+			OS:           runtime.GOOS,
+			Architecture: runtime.GOARCH,
+		}
+		index.Manifests = append(index.Manifests, desc)
+		return nil
 	}
-	// save copts
-	data, err := any.Marshal()
-	if err != nil {
-		return err
-	}
-	r := bytes.NewReader(data)
-	desc, err := writeContent(ctx, client.ContentStore(), images.MediaTypeContainerd1CheckpointOptions, c.ID+"-checkpoint-options", r)
-	if err != nil {
-		return err
-	}
-	desc.Platform = &imagespec.Platform{
-		OS:           runtime.GOOS,
-		Architecture: runtime.GOARCH,
-	}
-	index.Manifests = append(index.Manifests, desc)
-	return nil
 }
 
 // WithCheckpointRuntime includes the container runtime info
diff --git a/container_checkpoint_test.go b/container_checkpoint_test.go
index 5e037fb2f..d47e9e0ec 100644
--- a/container_checkpoint_test.go
+++ b/container_checkpoint_test.go
@@ -98,7 +98,7 @@ func TestCheckpointRestorePTY(t *testing.T) {
 		WithCheckpointRuntime,
 		WithCheckpointRW,
 		WithCheckpointTaskExit,
-		WithCheckpointTask,
+		WithCheckpointTask(false),
 	}...)
 	if err != nil {
 		t.Fatal(err)
@@ -134,11 +134,11 @@ func TestCheckpointRestorePTY(t *testing.T) {
 		WithRestoreSpec,
 		WithRestoreRuntime,
 		WithRestoreRW,
-	}...); err != nil {
+	}); err != nil {
 		t.Fatal(err)
 	}
 	if task, err = container.NewTask(ctx, direct.IOCreate,
-		WithTaskCheckpoint(checkpoint)); err != nil {
+		WithTaskCheckpoint(checkpoint, false)); err != nil {
 		t.Fatal(err)
 	}
 
@@ -212,7 +212,7 @@ func TestCheckpointRestore(t *testing.T) {
 	checkpoint, err := container.Checkpoint(ctx, testCheckpointName+"restore", []CheckpointOpts{
 		WithCheckpointRuntime,
 		WithCheckpointRW,
-		WithCheckpointTask,
+		WithCheckpointTask(false),
 	}...)
 	if err != nil {
 		t.Fatal(err)
@@ -232,10 +232,10 @@ func TestCheckpointRestore(t *testing.T) {
 		WithRestoreSpec,
 		WithRestoreRuntime,
 		WithRestoreRW,
-	}...); err != nil {
+	}); err != nil {
 		t.Fatal(err)
 	}
-	if task, err = container.NewTask(ctx, empty(), WithTaskCheckpoint(checkpoint)); err != nil {
+	if task, err = container.NewTask(ctx, empty(), WithTaskCheckpoint(checkpoint, false)); err != nil {
 		t.Fatal(err)
 	}
 	defer task.Delete(ctx)
@@ -300,7 +300,7 @@ func TestCheckpointRestoreNewContainer(t *testing.T) {
 	checkpoint, err := container.Checkpoint(ctx, testCheckpointName+"newcontainer", []CheckpointOpts{
 		WithCheckpointRuntime,
 		WithCheckpointRW,
-		WithCheckpointTask,
+		WithCheckpointTask(false),
 	}...)
 	if err != nil {
 		t.Fatal(err)
@@ -319,10 +319,10 @@ func TestCheckpointRestoreNewContainer(t *testing.T) {
 		WithRestoreSpec,
 		WithRestoreRuntime,
 		WithRestoreRW,
-	}...); err != nil {
+	}); err != nil {
 		t.Fatal(err)
 	}
-	if task, err = container.NewTask(ctx, empty(), WithTaskCheckpoint(checkpoint)); err != nil {
+	if task, err = container.NewTask(ctx, empty(), WithTaskCheckpoint(checkpoint, false)); err != nil {
 		t.Fatal(err)
 	}
 	defer task.Delete(ctx)
@@ -393,7 +393,7 @@ func TestCheckpointLeaveRunning(t *testing.T) {
 	if _, err := container.Checkpoint(ctx, testCheckpointName+"leaverunning", []CheckpointOpts{
 		WithCheckpointRuntime,
 		WithCheckpointRW,
-		WithCheckpointTask,
+		WithCheckpointTask(false),
 	}...); err != nil {
 		t.Fatal(err)
 	}
diff --git a/container_restore_opts.go b/container_restore_opts.go
index fb60e8de9..1a58e8487 100644
--- a/container_restore_opts.go
+++ b/container_restore_opts.go
@@ -18,10 +18,12 @@ package containerd
 
 import (
 	"context"
+	"encoding/json"
 
 	"github.com/containerd/containerd/containers"
 	"github.com/containerd/containerd/content"
 	"github.com/containerd/containerd/images"
+	"github.com/containerd/containerd/oci"
 	"github.com/gogo/protobuf/proto"
 	ptypes "github.com/gogo/protobuf/types"
 	"github.com/opencontainers/image-spec/identity"
@@ -147,3 +149,27 @@ func WithRestoreRW(ctx context.Context, id string, client *Client, checkpoint Im
 		return nil
 	}
 }
+
+func ParseSpecFromCheckpoint(ctx context.Context, store content.Store, checkpoint Image) (*oci.Spec, error) {
+	index, err := decodeIndex(ctx, store, checkpoint.Target())
+	if err != nil {
+		return nil, err
+	}
+	m, err := GetIndexByMediaType(index, images.MediaTypeContainerd1CheckpointConfig)
+	if err != nil {
+		return nil, err
+	}
+	data, err := content.ReadBlob(ctx, store, *m)
+	if err != nil {
+		return nil, errors.Wrap(err, "failed to read checkpoint config from content store")
+	}
+	var any ptypes.Any
+	if err = proto.Unmarshal(data, &any); err != nil {
+		return nil, err
+	}
+	var spec oci.Spec
+	if err = json.Unmarshal(any.Value, &spec); err != nil {
+		return nil, err
+	}
+	return &spec, nil
+}
diff --git a/external/external.go b/external/external.go
new file mode 100644
index 000000000..c6aeb12f1
--- /dev/null
+++ b/external/external.go
@@ -0,0 +1,99 @@
+package external
+
+import (
+	"github.com/YLonely/cer-manager/api/types"
+	"github.com/YLonely/cer-manager/client"
+	"github.com/containerd/typeurl"
+	ptypes "github.com/gogo/protobuf/types"
+	specs "github.com/opencontainers/runtime-spec/specs-go"
+	"github.com/pkg/errors"
+)
+
+type NamespaceInfo struct {
+	ID   int
+	Path string
+	Info interface{}
+}
+
+type CheckpointInfo struct {
+	Name      string
+	Namespace string
+}
+
+type ResourcesInfo struct {
+	Namespaces map[specs.LinuxNamespaceType]NamespaceInfo
+	Checkpoint *CheckpointInfo
+}
+
+const ResourcesExtensionKey = "ExternalResources"
+
+func GetNamespace(cli *client.Client, t specs.LinuxNamespaceType, namespace string, names ...string) (id int, path string, info interface{}, err error) {
+	refs := make([]types.Reference, 0, len(names))
+	for _, name := range names {
+		refs = append(refs, types.NewContainerdReference(
+			name,
+			namespace,
+		))
+	}
+	var tt types.NamespaceType
+	tt, err = NamespaceType(t)
+	if err != nil {
+		return
+	}
+	id, path, info, err = cli.GetNamespace(tt, refs[0], refs[1:]...)
+	return
+}
+
+func GetCheckpoint(cli *client.Client, namespace, name string) (string, error) {
+	return cli.GetCheckpoint(types.NewContainerdReference(
+		name,
+		namespace,
+	))
+}
+
+func PutNamespace(cli *client.Client, t specs.LinuxNamespaceType, id int) error {
+	tt, err := NamespaceType(t)
+	if err != nil {
+		return err
+	}
+	return cli.PutNamespace(tt, id)
+}
+
+func PutCheckpoint(cli *client.Client, namespace, name string) error {
+	return cli.PutCheckpoint(types.NewContainerdReference(
+		name,
+		namespace,
+	))
+}
+
+func NamespaceType(t specs.LinuxNamespaceType) (types.NamespaceType, error) {
+	var tt types.NamespaceType
+	switch t {
+	case specs.IPCNamespace:
+		tt = types.NamespaceIPC
+	case specs.MountNamespace:
+		tt = types.NamespaceMNT
+	case specs.UTSNamespace:
+		tt = types.NamespaceUTS
+	default:
+		return tt, errors.New("unsupported namespace type")
+	}
+	return tt, nil
+}
+
+func Parse(any *ptypes.Any) (*ResourcesInfo, error) {
+	if any == nil {
+		return nil, nil
+	}
+	var i interface{}
+	var err error
+	i, err = typeurl.UnmarshalAny(any)
+	if err != nil {
+		return nil, err
+	}
+	ret, ok := i.(*ResourcesInfo)
+	if !ok {
+		return nil, errors.New("can't convert any to ExternalResources")
+	}
+	return ret, nil
+}
diff --git a/images/handlers.go b/images/handlers.go
index 05a9017bc..8078dbb23 100644
--- a/images/handlers.go
+++ b/images/handlers.go
@@ -21,8 +21,10 @@ import (
 	"fmt"
 	"sort"
 
+	cermclient "github.com/YLonely/cer-manager/client"
 	"github.com/containerd/containerd/content"
 	"github.com/containerd/containerd/errdefs"
+	"github.com/containerd/containerd/external"
 	"github.com/containerd/containerd/platforms"
 	ocispec "github.com/opencontainers/image-spec/specs-go/v1"
 	"github.com/pkg/errors"
@@ -247,6 +249,35 @@ func FilterPlatforms(f HandlerFunc, m platforms.Matcher) HandlerFunc {
 	}
 }
 
+// FilterCheckpoints is a handler wrapper which filters out the container checkpoint files
+// if container external resources manager can provide them.
+func FilterCheckpoints(f HandlerFunc, name, namespace string) HandlerFunc {
+	return func(ctx context.Context, desc ocispec.Descriptor) ([]ocispec.Descriptor, error) {
+		children, err := f(ctx, desc)
+		if err != nil {
+			return children, err
+		}
+
+		var descs []ocispec.Descriptor
+		cli, err := cermclient.Default()
+		if err != nil {
+			// ignore errors here
+			return children, nil
+		}
+		defer cli.Close()
+		_, err = external.GetCheckpoint(cli, namespace, name)
+		if err != nil {
+			return children, nil
+		}
+		for _, c := range children {
+			if c.MediaType != MediaTypeContainerd1CheckpointStargz && c.MediaType != MediaTypeContainerd1Checkpoint {
+				descs = append(descs, c)
+			}
+		}
+		return descs, nil
+	}
+}
+
 // LimitManifests is a handler wrapper which filters the manifest descriptors
 // returned using the provided platform.
 // The results will be ordered according to the comparison operator and
diff --git a/images/image.go b/images/image.go
index 1868ee88d..f5d60607a 100644
--- a/images/image.go
+++ b/images/image.go
@@ -205,6 +205,9 @@ func Manifest(ctx context.Context, provider content.Provider, image ocispec.Desc
 
 			var descs []ocispec.Descriptor
 			for _, d := range idx.Manifests {
+				if IsCheckpointConfig(d.MediaType) {
+					continue
+				}
 				if d.Platform == nil || platform.Match(*d.Platform) {
 					descs = append(descs, d)
 				}
@@ -358,7 +361,7 @@ func Children(ctx context.Context, provider content.Provider, desc ocispec.Descr
 
 		descs = append(descs, index.Manifests...)
 	default:
-		if IsLayerType(desc.MediaType) || IsKnownConfig(desc.MediaType) {
+		if IsLayerType(desc.MediaType) || IsKnownConfig(desc.MediaType) || IsCheckpointConfig(desc.MediaType) {
 			// childless data types.
 			return nil, nil
 		}
diff --git a/images/mediatypes.go b/images/mediatypes.go
index c51897d25..af60568d1 100644
--- a/images/mediatypes.go
+++ b/images/mediatypes.go
@@ -40,6 +40,7 @@ const (
 	MediaTypeDockerSchema2ManifestList     = "application/vnd.docker.distribution.manifest.list.v2+json"
 	// Checkpoint/Restore Media Types
 	MediaTypeContainerd1Checkpoint               = "application/vnd.containerd.container.criu.checkpoint.criu.tar"
+	MediaTypeContainerd1CheckpointStargz         = "application/vnd.containerd.container.criu.checkpoint.criu.stargz"
 	MediaTypeContainerd1CheckpointPreDump        = "application/vnd.containerd.container.criu.checkpoint.predump.tar"
 	MediaTypeContainerd1Resource                 = "application/vnd.containerd.container.resource.tar"
 	MediaTypeContainerd1RW                       = "application/vnd.containerd.container.rw.tar"
@@ -120,7 +121,18 @@ func IsLayerType(mt string) bool {
 func IsKnownConfig(mt string) bool {
 	switch mt {
 	case MediaTypeDockerSchema2Config, ocispec.MediaTypeImageConfig,
-		MediaTypeContainerd1Checkpoint, MediaTypeContainerd1CheckpointConfig:
+		MediaTypeContainerd1Checkpoint, MediaTypeContainerd1CheckpointConfig,
+		MediaTypeContainerd1CheckpointStargz:
+		return true
+	}
+	return false
+}
+
+func IsCheckpointConfig(mt string) bool {
+	switch mt {
+	case MediaTypeContainerd1CheckpointOptions, ocispec.MediaTypeImageLayerGzip,
+		MediaTypeContainerd1Checkpoint, MediaTypeContainerd1CheckpointStargz,
+		MediaTypeContainerd1CheckpointConfig, MediaTypeContainerd1CheckpointRuntimeOptions:
 		return true
 	}
 	return false
diff --git a/pkg/api/runtimeoptions/v1/api.pb.go b/pkg/api/runtimeoptions/v1/api.pb.go
new file mode 100644
index 000000000..e8e250caa
--- /dev/null
+++ b/pkg/api/runtimeoptions/v1/api.pb.go
@@ -0,0 +1,401 @@
+// Code generated by protoc-gen-gogo. DO NOT EDIT.
+// source: github.com/containerd/containerd/pkg/cri/runtimeoptions/v1/api.proto
+
+package cri_runtimeoptions_v1
+
+import (
+	fmt "fmt"
+	_ "github.com/gogo/protobuf/gogoproto"
+	proto "github.com/gogo/protobuf/proto"
+	io "io"
+	math "math"
+	math_bits "math/bits"
+	reflect "reflect"
+	strings "strings"
+)
+
+// Reference imports to suppress errors if they are not otherwise used.
+var _ = proto.Marshal
+var _ = fmt.Errorf
+var _ = math.Inf
+
+// This is a compile-time assertion to ensure that this generated file
+// is compatible with the proto package it is being compiled against.
+// A compilation error at this line likely means your copy of the
+// proto package needs to be updated.
+const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package
+
+type Options struct {
+	// TypeUrl specifies the type of the content inside the config file.
+	TypeUrl string `protobuf:"bytes,1,opt,name=type_url,json=typeUrl,proto3" json:"type_url,omitempty"`
+	// ConfigPath specifies the filesystem location of the config file
+	// used by the runtime.
+	ConfigPath           string   `protobuf:"bytes,2,opt,name=config_path,json=configPath,proto3" json:"config_path,omitempty"`
+	XXX_NoUnkeyedLiteral struct{} `json:"-"`
+	XXX_sizecache        int32    `json:"-"`
+}
+
+func (m *Options) Reset()      { *m = Options{} }
+func (*Options) ProtoMessage() {}
+func (*Options) Descriptor() ([]byte, []int) {
+	return fileDescriptor_fe2c17d0693aba39, []int{0}
+}
+func (m *Options) XXX_Unmarshal(b []byte) error {
+	return m.Unmarshal(b)
+}
+func (m *Options) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
+	if deterministic {
+		return xxx_messageInfo_Options.Marshal(b, m, deterministic)
+	} else {
+		b = b[:cap(b)]
+		n, err := m.MarshalToSizedBuffer(b)
+		if err != nil {
+			return nil, err
+		}
+		return b[:n], nil
+	}
+}
+func (m *Options) XXX_Merge(src proto.Message) {
+	xxx_messageInfo_Options.Merge(m, src)
+}
+func (m *Options) XXX_Size() int {
+	return m.Size()
+}
+func (m *Options) XXX_DiscardUnknown() {
+	xxx_messageInfo_Options.DiscardUnknown(m)
+}
+
+var xxx_messageInfo_Options proto.InternalMessageInfo
+
+func (m *Options) GetTypeUrl() string {
+	if m != nil {
+		return m.TypeUrl
+	}
+	return ""
+}
+
+func (m *Options) GetConfigPath() string {
+	if m != nil {
+		return m.ConfigPath
+	}
+	return ""
+}
+
+func init() {
+	proto.RegisterType((*Options)(nil), "cri.runtimeoptions.v1.Options")
+}
+
+func init() {
+	proto.RegisterFile("github.com/containerd/containerd/pkg/cri/runtimeoptions/v1/api.proto", fileDescriptor_fe2c17d0693aba39)
+}
+
+var fileDescriptor_fe2c17d0693aba39 = []byte{
+	// 230 bytes of a gzipped FileDescriptorProto
+	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe2, 0x72, 0x49, 0xcf, 0x2c, 0xc9,
+	0x28, 0x4d, 0xd2, 0x4b, 0xce, 0xcf, 0xd5, 0x4f, 0xce, 0xcf, 0x2b, 0x49, 0xcc, 0xcc, 0x4b, 0x2d,
+	0x4a, 0x41, 0x66, 0x16, 0x64, 0xa7, 0xeb, 0x27, 0x17, 0x65, 0xea, 0x17, 0x95, 0xe6, 0x95, 0x64,
+	0xe6, 0xa6, 0xe6, 0x17, 0x94, 0x64, 0xe6, 0xe7, 0x15, 0xeb, 0x97, 0x19, 0xea, 0x27, 0x16, 0x64,
+	0xea, 0x15, 0x14, 0xe5, 0x97, 0xe4, 0x0b, 0x89, 0x26, 0x17, 0x65, 0xea, 0xa1, 0x2a, 0xd0, 0x2b,
+	0x33, 0x94, 0xd2, 0x45, 0x32, 0x3c, 0x3d, 0x3f, 0x3d, 0x5f, 0x1f, 0xac, 0x3a, 0xa9, 0x34, 0x0d,
+	0xcc, 0x03, 0x73, 0xc0, 0x2c, 0x88, 0x29, 0x4a, 0xae, 0x5c, 0xec, 0xfe, 0x10, 0xcd, 0x42, 0x92,
+	0x5c, 0x1c, 0x25, 0x95, 0x05, 0xa9, 0xf1, 0xa5, 0x45, 0x39, 0x12, 0x8c, 0x0a, 0x8c, 0x1a, 0x9c,
+	0x41, 0xec, 0x20, 0x7e, 0x68, 0x51, 0x8e, 0x90, 0x3c, 0x17, 0x77, 0x72, 0x7e, 0x5e, 0x5a, 0x66,
+	0x7a, 0x7c, 0x41, 0x62, 0x49, 0x86, 0x04, 0x13, 0x58, 0x96, 0x0b, 0x22, 0x14, 0x90, 0x58, 0x92,
+	0xe1, 0x94, 0x77, 0xe2, 0xa1, 0x1c, 0xe3, 0x8d, 0x87, 0x72, 0x0c, 0x0d, 0x8f, 0xe4, 0x18, 0x4f,
+	0x3c, 0x92, 0x63, 0xbc, 0xf0, 0x48, 0x8e, 0xf1, 0xc1, 0x23, 0x39, 0xc6, 0x09, 0x8f, 0xe5, 0x18,
+	0xa2, 0x02, 0x88, 0xf2, 0x70, 0x62, 0x01, 0x16, 0x0f, 0x5b, 0x27, 0x17, 0x65, 0xc6, 0xa3, 0x8a,
+	0xc6, 0x97, 0x19, 0x26, 0xb1, 0x81, 0x5d, 0x6f, 0x0c, 0x08, 0x00, 0x00, 0xff, 0xff, 0x1f, 0x30,
+	0x46, 0x6b, 0x4b, 0x01, 0x00, 0x00,
+}
+
+func (m *Options) Marshal() (dAtA []byte, err error) {
+	size := m.Size()
+	dAtA = make([]byte, size)
+	n, err := m.MarshalToSizedBuffer(dAtA[:size])
+	if err != nil {
+		return nil, err
+	}
+	return dAtA[:n], nil
+}
+
+func (m *Options) MarshalTo(dAtA []byte) (int, error) {
+	size := m.Size()
+	return m.MarshalToSizedBuffer(dAtA[:size])
+}
+
+func (m *Options) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+	i := len(dAtA)
+	_ = i
+	var l int
+	_ = l
+	if len(m.ConfigPath) > 0 {
+		i -= len(m.ConfigPath)
+		copy(dAtA[i:], m.ConfigPath)
+		i = encodeVarintApi(dAtA, i, uint64(len(m.ConfigPath)))
+		i--
+		dAtA[i] = 0x12
+	}
+	if len(m.TypeUrl) > 0 {
+		i -= len(m.TypeUrl)
+		copy(dAtA[i:], m.TypeUrl)
+		i = encodeVarintApi(dAtA, i, uint64(len(m.TypeUrl)))
+		i--
+		dAtA[i] = 0xa
+	}
+	return len(dAtA) - i, nil
+}
+
+func encodeVarintApi(dAtA []byte, offset int, v uint64) int {
+	offset -= sovApi(v)
+	base := offset
+	for v >= 1<<7 {
+		dAtA[offset] = uint8(v&0x7f | 0x80)
+		v >>= 7
+		offset++
+	}
+	dAtA[offset] = uint8(v)
+	return base
+}
+func (m *Options) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	l = len(m.TypeUrl)
+	if l > 0 {
+		n += 1 + l + sovApi(uint64(l))
+	}
+	l = len(m.ConfigPath)
+	if l > 0 {
+		n += 1 + l + sovApi(uint64(l))
+	}
+	return n
+}
+
+func sovApi(x uint64) (n int) {
+	return (math_bits.Len64(x|1) + 6) / 7
+}
+func sozApi(x uint64) (n int) {
+	return sovApi(uint64((x << 1) ^ uint64((int64(x) >> 63))))
+}
+func (this *Options) String() string {
+	if this == nil {
+		return "nil"
+	}
+	s := strings.Join([]string{`&Options{`,
+		`TypeUrl:` + fmt.Sprintf("%v", this.TypeUrl) + `,`,
+		`ConfigPath:` + fmt.Sprintf("%v", this.ConfigPath) + `,`,
+		`}`,
+	}, "")
+	return s
+}
+func valueToStringApi(v interface{}) string {
+	rv := reflect.ValueOf(v)
+	if rv.IsNil() {
+		return "nil"
+	}
+	pv := reflect.Indirect(rv).Interface()
+	return fmt.Sprintf("*%v", pv)
+}
+func (m *Options) Unmarshal(dAtA []byte) error {
+	l := len(dAtA)
+	iNdEx := 0
+	for iNdEx < l {
+		preIndex := iNdEx
+		var wire uint64
+		for shift := uint(0); ; shift += 7 {
+			if shift >= 64 {
+				return ErrIntOverflowApi
+			}
+			if iNdEx >= l {
+				return io.ErrUnexpectedEOF
+			}
+			b := dAtA[iNdEx]
+			iNdEx++
+			wire |= uint64(b&0x7F) << shift
+			if b < 0x80 {
+				break
+			}
+		}
+		fieldNum := int32(wire >> 3)
+		wireType := int(wire & 0x7)
+		if wireType == 4 {
+			return fmt.Errorf("proto: Options: wiretype end group for non-group")
+		}
+		if fieldNum <= 0 {
+			return fmt.Errorf("proto: Options: illegal tag %d (wire type %d)", fieldNum, wire)
+		}
+		switch fieldNum {
+		case 1:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field TypeUrl", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowApi
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= uint64(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthApi
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex < 0 {
+				return ErrInvalidLengthApi
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.TypeUrl = string(dAtA[iNdEx:postIndex])
+			iNdEx = postIndex
+		case 2:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field ConfigPath", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowApi
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= uint64(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthApi
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex < 0 {
+				return ErrInvalidLengthApi
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.ConfigPath = string(dAtA[iNdEx:postIndex])
+			iNdEx = postIndex
+		default:
+			iNdEx = preIndex
+			skippy, err := skipApi(dAtA[iNdEx:])
+			if err != nil {
+				return err
+			}
+			if skippy < 0 {
+				return ErrInvalidLengthApi
+			}
+			if (iNdEx + skippy) < 0 {
+				return ErrInvalidLengthApi
+			}
+			if (iNdEx + skippy) > l {
+				return io.ErrUnexpectedEOF
+			}
+			iNdEx += skippy
+		}
+	}
+
+	if iNdEx > l {
+		return io.ErrUnexpectedEOF
+	}
+	return nil
+}
+func skipApi(dAtA []byte) (n int, err error) {
+	l := len(dAtA)
+	iNdEx := 0
+	depth := 0
+	for iNdEx < l {
+		var wire uint64
+		for shift := uint(0); ; shift += 7 {
+			if shift >= 64 {
+				return 0, ErrIntOverflowApi
+			}
+			if iNdEx >= l {
+				return 0, io.ErrUnexpectedEOF
+			}
+			b := dAtA[iNdEx]
+			iNdEx++
+			wire |= (uint64(b) & 0x7F) << shift
+			if b < 0x80 {
+				break
+			}
+		}
+		wireType := int(wire & 0x7)
+		switch wireType {
+		case 0:
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return 0, ErrIntOverflowApi
+				}
+				if iNdEx >= l {
+					return 0, io.ErrUnexpectedEOF
+				}
+				iNdEx++
+				if dAtA[iNdEx-1] < 0x80 {
+					break
+				}
+			}
+		case 1:
+			iNdEx += 8
+		case 2:
+			var length int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return 0, ErrIntOverflowApi
+				}
+				if iNdEx >= l {
+					return 0, io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				length |= (int(b) & 0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if length < 0 {
+				return 0, ErrInvalidLengthApi
+			}
+			iNdEx += length
+		case 3:
+			depth++
+		case 4:
+			if depth == 0 {
+				return 0, ErrUnexpectedEndOfGroupApi
+			}
+			depth--
+		case 5:
+			iNdEx += 4
+		default:
+			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
+		}
+		if iNdEx < 0 {
+			return 0, ErrInvalidLengthApi
+		}
+		if depth == 0 {
+			return iNdEx, nil
+		}
+	}
+	return 0, io.ErrUnexpectedEOF
+}
+
+var (
+	ErrInvalidLengthApi        = fmt.Errorf("proto: negative length found during unmarshaling")
+	ErrIntOverflowApi          = fmt.Errorf("proto: integer overflow")
+	ErrUnexpectedEndOfGroupApi = fmt.Errorf("proto: unexpected end of group")
+)
diff --git a/pkg/cri/constants/constants.go b/pkg/cri/constants/constants.go
index b38221502..965d74757 100644
--- a/pkg/cri/constants/constants.go
+++ b/pkg/cri/constants/constants.go
@@ -22,5 +22,6 @@ const (
 	// K8sContainerdNamespace is the namespace we use to connect containerd.
 	K8sContainerdNamespace = "k8s.io"
 	// CRIVersion is the CRI version supported by the CRI plugin.
-	CRIVersion = "v1alpha2"
+	CRIVersion            = "v1alpha2"
+	LabelCheckpointPrefix = "checkpoint-"
 )
diff --git a/pkg/cri/server/container_create.go b/pkg/cri/server/container_create.go
index 9360ba056..8211d69ed 100644
--- a/pkg/cri/server/container_create.go
+++ b/pkg/cri/server/container_create.go
@@ -242,8 +242,39 @@ func (c *criService) CreateContainer(ctx context.Context, r *runtime.CreateConta
 		containerd.WithContainerLabels(containerLabels),
 		containerd.WithContainerExtension(containerMetadataExtension, &meta))
 	var cntr containerd.Container
-	if cntr, err = c.client.NewContainer(ctx, id, opts...); err != nil {
-		return nil, errors.Wrap(err, "failed to create containerd container")
+
+	checkpointImgs := parseCheckpointImages(sandboxConfig.Labels)
+	restoreContainer := false
+	if len(checkpointImgs) > 0 {
+		refs := map[string]struct{}{}
+		for _, ref := range image.References {
+			refs[ref] = struct{}{}
+		}
+		for _, imgName := range checkpointImgs {
+			if _, exists := refs[imgName]; exists {
+				checkpoint, err := c.client.GetImage(ctx, imgName)
+				if err != nil {
+					return nil, errors.Wrapf(err, "failed to get checkpoint %q from containerd", imgName)
+				}
+				ropts, copts, err := c.containerRestoreOpts(ctx, config, sandboxPid, checkpoint)
+				if err != nil {
+					return nil, err
+				}
+				copts = append(copts,
+					containerd.WithContainerLabels(containerLabels),
+					containerd.WithContainerExtension(containerMetadataExtension, &meta))
+				if cntr, err = c.client.Restore(ctx, id, checkpoint, ropts, copts...); err != nil {
+					return nil, errors.Wrap(err, "failed to restore containerd container")
+				}
+				restoreContainer = true
+				break
+			}
+		}
+	}
+	if !restoreContainer {
+		if cntr, err = c.client.NewContainer(ctx, id, opts...); err != nil {
+			return nil, errors.Wrap(err, "failed to create containerd container")
+		}
 	}
 	defer func() {
 		if retErr != nil {
diff --git a/pkg/cri/server/container_create_linux.go b/pkg/cri/server/container_create_linux.go
index 3e6579093..0eb33f824 100644
--- a/pkg/cri/server/container_create_linux.go
+++ b/pkg/cri/server/container_create_linux.go
@@ -23,19 +23,25 @@ import (
 	"strconv"
 	"strings"
 
+	cmclient "github.com/YLonely/cer-manager/client"
 	"github.com/containerd/cgroups"
+	"github.com/containerd/containerd"
 	"github.com/containerd/containerd/contrib/apparmor"
 	"github.com/containerd/containerd/contrib/seccomp"
+	"github.com/containerd/containerd/external"
 	"github.com/containerd/containerd/oci"
 	imagespec "github.com/opencontainers/image-spec/specs-go/v1"
+	"github.com/opencontainers/runtime-spec/specs-go"
 	runtimespec "github.com/opencontainers/runtime-spec/specs-go"
 	selinux "github.com/opencontainers/selinux/go-selinux"
 	"github.com/opencontainers/selinux/go-selinux/label"
 	"github.com/pkg/errors"
+	"golang.org/x/net/context"
 	runtime "k8s.io/cri-api/pkg/apis/runtime/v1alpha2"
 
 	"github.com/containerd/containerd/pkg/cri/annotations"
 	"github.com/containerd/containerd/pkg/cri/config"
+	"github.com/containerd/containerd/pkg/cri/constants"
 	customopts "github.com/containerd/containerd/pkg/cri/opts"
 )
 
@@ -358,6 +364,53 @@ func (c *criService) generateSeccompSpecOpts(seccompProf string, privileged, sec
 	}
 }
 
+func (c *criService) containerRestoreOpts(ctx context.Context, config *runtime.ContainerConfig, pid uint32, checkpoint containerd.Image) (ropts []containerd.RestoreOpts, copts []containerd.NewContainerOpts, err error) {
+	var (
+		spec              *oci.Spec
+		externalResources = &external.ResourcesInfo{
+			Namespaces: map[runtimespec.LinuxNamespaceType]external.NamespaceInfo{},
+		}
+		securityContext = config.GetLinux().GetSecurityContext()
+		cli             *cmclient.Client
+		id              int
+		path            string
+		info            interface{}
+	)
+	ropts = append(ropts, containerd.WithRestoreRuntime)
+	spec, err = containerd.ParseSpecFromCheckpoint(ctx, c.client.ContentStore(), checkpoint)
+	if err != nil {
+		err = errors.Wrap(err, "failed to parse spec from checkpoint image")
+		return
+	}
+	cli, err = cmclient.Default()
+	if err != nil {
+		err = errors.Wrap(err, "failed to create cer-manager client")
+		return
+	}
+	defer cli.Close()
+	id, path, info, err = external.GetNamespace(cli, specs.MountNamespace, constants.K8sContainerdNamespace, checkpoint.Name())
+	if err != nil {
+		return
+	}
+	externalResources.Namespaces[specs.MountNamespace] = external.NamespaceInfo{
+		ID:   id,
+		Info: info,
+		Path: path,
+	}
+	specOpts := []oci.SpecOpts{
+		oci.WithLinuxNamespace(runtimespec.LinuxNamespace{
+			Type: specs.MountNamespace,
+			Path: path,
+		}),
+		customopts.WithPodNamespaces(securityContext, pid),
+	}
+	copts = append(copts,
+		containerd.WithSpec(spec, specOpts...),
+		containerd.WithContainerExtension(external.ResourcesExtensionKey, externalResources),
+	)
+	return
+}
+
 // generateApparmorSpecOpts generates containerd SpecOpts for apparmor.
 func generateApparmorSpecOpts(apparmorProf string, privileged, apparmorEnabled bool) (oci.SpecOpts, error) {
 	if !apparmorEnabled {
diff --git a/pkg/cri/server/container_start.go b/pkg/cri/server/container_start.go
index 285b98a06..854b64242 100644
--- a/pkg/cri/server/container_start.go
+++ b/pkg/cri/server/container_start.go
@@ -98,8 +98,35 @@ func (c *criService) StartContainer(ctx context.Context, r *runtime.StartContain
 	if err != nil {
 		return nil, errors.Wrap(err, "failed to get container info")
 	}
-
-	taskOpts := c.taskOpts(ctrInfo.Runtime.Name)
+	taskOpts := []containerd.NewTaskOpts{}
+	checkpointImgs := parseCheckpointImages(sandbox.Config.Labels)
+	restoreTask := false
+	if len(checkpointImgs) > 0 {
+		image, err := c.localResolve(config.GetImage().GetImage())
+		if err != nil {
+			return nil, errors.Wrapf(err, "failed to resolve image %q", config.GetImage().GetImage())
+		}
+		refs := map[string]struct{}{}
+		for _, ref := range image.References {
+			refs[ref] = struct{}{}
+		}
+		for _, name := range checkpointImgs {
+			if _, exists := refs[name]; exists {
+				checkpoint, err := c.client.GetImage(ctx, name)
+				if err != nil {
+					return nil, errors.Wrapf(err, "failed to get checkpoint %q from containerd", name)
+				}
+				taskOpts = append(taskOpts,
+					containerd.WithTaskCheckpoint(checkpoint, true),
+				)
+				restoreTask = true
+				break
+			}
+		}
+	}
+	if !restoreTask {
+		taskOpts = c.taskOpts(ctrInfo.Runtime.Name)
+	}
 	task, err := container.NewTask(ctx, ioCreation, taskOpts...)
 	if err != nil {
 		return nil, errors.Wrap(err, "failed to create containerd task")
diff --git a/pkg/cri/server/sandbox_run.go b/pkg/cri/server/sandbox_run.go
index 909122672..885821428 100644
--- a/pkg/cri/server/sandbox_run.go
+++ b/pkg/cri/server/sandbox_run.go
@@ -25,6 +25,7 @@ import (
 	"github.com/containerd/containerd"
 	containerdio "github.com/containerd/containerd/cio"
 	"github.com/containerd/containerd/errdefs"
+	"github.com/containerd/containerd/external"
 	"github.com/containerd/containerd/log"
 	cni "github.com/containerd/go-cni"
 	"github.com/containerd/nri"
@@ -45,6 +46,7 @@ import (
 	ctrdutil "github.com/containerd/containerd/pkg/cri/util"
 	"github.com/containerd/containerd/pkg/netns"
 	"github.com/containerd/containerd/snapshots"
+	"github.com/opencontainers/runtime-spec/specs-go"
 	selinux "github.com/opencontainers/selinux/go-selinux"
 )
 
@@ -152,11 +154,14 @@ func (c *criService) RunPodSandbox(ctx context.Context, r *runtime.RunPodSandbox
 		}
 	}
 
+	externalResources := &external.ResourcesInfo{
+		Namespaces: map[specs.LinuxNamespaceType]external.NamespaceInfo{},
+	}
 	// Create sandbox container.
 	// NOTE: sandboxContainerSpec SHOULD NOT have side
 	// effect, e.g. accessing/creating files, so that we can test
 	// it safely.
-	spec, err := c.sandboxContainerSpec(id, config, &image.ImageSpec.Config, sandbox.NetNSPath, ociRuntime.PodAnnotations)
+	spec, err := c.sandboxContainerSpec(id, config, &image.ImageSpec.Config, sandbox.NetNSPath, ociRuntime.PodAnnotations, externalResources)
 	if err != nil {
 		return nil, errors.Wrap(err, "failed to generate sandbox container spec")
 	}
@@ -199,6 +204,7 @@ func (c *criService) RunPodSandbox(ctx context.Context, r *runtime.RunPodSandbox
 		containerd.WithSpec(spec, specOpts...),
 		containerd.WithContainerLabels(sandboxLabels),
 		containerd.WithContainerExtension(sandboxMetadataExtension, &sandbox.Metadata),
+		containerd.WithContainerExtension(external.ResourcesExtensionKey, externalResources),
 		containerd.WithRuntime(ociRuntime.Type, runtimeOpts)}
 
 	container, err := c.client.NewContainer(ctx, id, opts...)
diff --git a/pkg/cri/server/sandbox_run_linux.go b/pkg/cri/server/sandbox_run_linux.go
index f043504e6..3dbef7fc3 100644
--- a/pkg/cri/server/sandbox_run_linux.go
+++ b/pkg/cri/server/sandbox_run_linux.go
@@ -21,7 +21,9 @@ import (
 	"os"
 	"strings"
 
+	cmclient "github.com/YLonely/cer-manager/client"
 	"github.com/containerd/containerd"
+	"github.com/containerd/containerd/external"
 	"github.com/containerd/containerd/oci"
 	"github.com/containerd/containerd/plugin"
 	imagespec "github.com/opencontainers/image-spec/specs-go/v1"
@@ -32,12 +34,13 @@ import (
 	runtime "k8s.io/cri-api/pkg/apis/runtime/v1alpha2"
 
 	"github.com/containerd/containerd/pkg/cri/annotations"
+	"github.com/containerd/containerd/pkg/cri/constants"
 	customopts "github.com/containerd/containerd/pkg/cri/opts"
 	osinterface "github.com/containerd/containerd/pkg/os"
 )
 
 func (c *criService) sandboxContainerSpec(id string, config *runtime.PodSandboxConfig,
-	imageConfig *imagespec.ImageConfig, nsPath string, runtimePodAnnotations []string) (_ *runtimespec.Spec, retErr error) {
+	imageConfig *imagespec.ImageConfig, nsPath string, runtimePodAnnotations []string, externalResources *external.ResourcesInfo) (_ *runtimespec.Spec, retErr error) {
 	// Creates a spec Generator with the default spec.
 	// TODO(random-liu): [P1] Compare the default settings with docker and containerd default.
 	specOpts := []oci.SpecOpts{
@@ -92,6 +95,29 @@ func (c *criService) sandboxContainerSpec(id string, config *runtime.PodSandboxC
 	}
 	if nsOptions.GetIpc() == runtime.NamespaceMode_NODE {
 		specOpts = append(specOpts, customopts.WithoutNamespace(runtimespec.IPCNamespace))
+	} else {
+		checkpointImgs := parseCheckpointImages(config.Labels)
+		if len(checkpointImgs) > 0 && externalResources != nil {
+			cli, err := cmclient.Default()
+			if err != nil {
+				return nil, errors.Wrap(err, "failed to create cer-manager client")
+			}
+			defer cli.Close()
+			id, path, _, err := external.GetNamespace(cli, runtimespec.IPCNamespace, constants.K8sContainerdNamespace, checkpointImgs...)
+			if err != nil {
+				return nil, err
+			}
+			specOpts = append(specOpts, oci.WithLinuxNamespace(
+				runtimespec.LinuxNamespace{
+					Type: runtimespec.IPCNamespace,
+					Path: path,
+				},
+			))
+			externalResources.Namespaces[runtimespec.IPCNamespace] = external.NamespaceInfo{
+				ID:   id,
+				Path: path,
+			}
+		}
 	}
 
 	// It's fine to generate the spec before the sandbox /dev/shm
@@ -312,3 +338,13 @@ func (c *criService) taskOpts(runtimeType string) []containerd.NewTaskOpts {
 
 	return taskOpts
 }
+
+func parseCheckpointImages(labels map[string]string) []string {
+	images := []string{}
+	for k, v := range labels {
+		if strings.HasPrefix(k, constants.LabelCheckpointPrefix) {
+			images = append(images, strings.ReplaceAll(strings.TrimPrefix(k, constants.LabelCheckpointPrefix), "_", "/")+":"+v)
+		}
+	}
+	return images
+}
diff --git a/pkg/cri/server/sandbox_run_linux_test.go b/pkg/cri/server/sandbox_run_linux_test.go
index 91c7d4eb7..ce1e58e6d 100644
--- a/pkg/cri/server/sandbox_run_linux_test.go
+++ b/pkg/cri/server/sandbox_run_linux_test.go
@@ -157,7 +157,7 @@ func TestLinuxSandboxContainerSpec(t *testing.T) {
 		if test.configChange != nil {
 			test.configChange(config)
 		}
-		spec, err := c.sandboxContainerSpec(testID, config, imageConfig, nsPath, nil)
+		spec, err := c.sandboxContainerSpec(testID, config, imageConfig, nsPath, nil, nil)
 		if test.expectErr {
 			assert.Error(t, err)
 			assert.Nil(t, spec)
@@ -416,7 +416,7 @@ func TestSandboxDisableCgroup(t *testing.T) {
 	config, imageConfig, _ := getRunPodSandboxTestData()
 	c := newTestCRIService()
 	c.config.DisableCgroup = true
-	spec, err := c.sandboxContainerSpec("test-id", config, imageConfig, "test-cni", []string{})
+	spec, err := c.sandboxContainerSpec("test-id", config, imageConfig, "test-cni", []string{}, nil)
 	require.NoError(t, err)
 
 	t.Log("resource limit should not be set")
diff --git a/pkg/cri/server/sandbox_run_test.go b/pkg/cri/server/sandbox_run_test.go
index d47af13f3..9c13d9ce3 100644
--- a/pkg/cri/server/sandbox_run_test.go
+++ b/pkg/cri/server/sandbox_run_test.go
@@ -97,7 +97,7 @@ func TestSandboxContainerSpec(t *testing.T) {
 			test.imageConfigChange(imageConfig)
 		}
 		spec, err := c.sandboxContainerSpec(testID, config, imageConfig, nsPath,
-			test.podAnnotations)
+			test.podAnnotations, nil)
 		if test.expectErr {
 			assert.Error(t, err)
 			assert.Nil(t, spec)
diff --git a/pkg/cri/store/image/image.go b/pkg/cri/store/image/image.go
index 7eaadbb33..7f08b3a3b 100644
--- a/pkg/cri/store/image/image.go
+++ b/pkg/cri/store/image/image.go
@@ -24,6 +24,7 @@ import (
 	"github.com/containerd/containerd"
 	"github.com/containerd/containerd/content"
 	"github.com/containerd/containerd/errdefs"
+	"github.com/containerd/containerd/images"
 	imagedigest "github.com/opencontainers/go-digest"
 	"github.com/opencontainers/go-digest/digestset"
 	imageidentity "github.com/opencontainers/image-spec/identity"
@@ -128,18 +129,39 @@ func getImage(ctx context.Context, i containerd.Image) (*Image, error) {
 	if err != nil {
 		return nil, errors.Wrap(err, "get image compressed resource size")
 	}
-
-	desc, err := i.Config(ctx)
+	var id string
+	var config imagespec.Descriptor
+	var ociimage imagespec.Image
+	isCheckpoint := false
+	if i.Target().MediaType == imagespec.MediaTypeImageIndex {
+		// i maybe a checkpoint
+		p, err := content.ReadBlob(ctx, i.ContentStore(), i.Target())
+		if err != nil {
+			return nil, errors.Wrap(err, "get image target from containerd")
+		}
+		var idx imagespec.Index
+		if err = json.Unmarshal(p, &idx); err != nil {
+			return nil, err
+		}
+		for _, m := range idx.Manifests {
+			if m.MediaType == images.MediaTypeContainerd1CheckpointConfig {
+				isCheckpoint = true
+				id = m.Digest.String()
+				break
+			}
+		}
+	}
+	config, err = i.Config(ctx)
 	if err != nil {
 		return nil, errors.Wrap(err, "get image config descriptor")
 	}
-	id := desc.Digest.String()
-
-	rb, err := content.ReadBlob(ctx, i.ContentStore(), desc)
+	if !isCheckpoint {
+		id = config.Digest.String()
+	}
+	rb, err := content.ReadBlob(ctx, i.ContentStore(), config)
 	if err != nil {
 		return nil, errors.Wrap(err, "read image config from content store")
 	}
-	var ociimage imagespec.Image
 	if err := json.Unmarshal(rb, &ociimage); err != nil {
 		return nil, errors.Wrapf(err, "unmarshal image config %s", rb)
 	}
diff --git a/pull.go b/pull.go
index 36365513f..fc7cc29b7 100644
--- a/pull.go
+++ b/pull.go
@@ -18,6 +18,7 @@ package containerd
 
 import (
 	"context"
+	"encoding/json"
 
 	"github.com/containerd/containerd/errdefs"
 	"github.com/containerd/containerd/images"
@@ -145,6 +146,25 @@ func (c *Client) fetch(ctx context.Context, rCtx *RemoteContext, ref string, lim
 		limiter       *semaphore.Weighted
 	)
 
+	if desc.MediaType == images.MediaTypeDockerSchema2ManifestList && rCtx.PlatformMatcher != nil {
+		rd, err := fetcher.Fetch(ctx, desc)
+		if err != nil {
+			return images.Image{}, err
+		}
+		defer rd.Close()
+		index := &ocispec.Index{}
+		d := json.NewDecoder(rd)
+		if err = d.Decode(&index); err != nil {
+			return images.Image{}, err
+		}
+		for _, m := range index.Manifests {
+			if m.Platform != nil && rCtx.PlatformMatcher.Match(*m.Platform) {
+				desc = m
+				break
+			}
+		}
+	}
+
 	if desc.MediaType == images.MediaTypeDockerSchema1Manifest && rCtx.ConvertSchema1 {
 		schema1Converter := schema1.NewConverter(store, fetcher)
 
@@ -173,6 +193,8 @@ func (c *Client) fetch(ctx context.Context, rCtx *RemoteContext, ref string, lim
 			childrenHandler = images.LimitManifests(childrenHandler, rCtx.PlatformMatcher, limit)
 		}
 
+		childrenHandler = images.FilterCheckpoints(childrenHandler, ref, c.defaultns)
+
 		// set isConvertible to true if there is application/octet-stream media type
 		convertibleHandler := images.HandlerFunc(
 			func(_ context.Context, desc ocispec.Descriptor) ([]ocispec.Descriptor, error) {
diff --git a/runtime/runtime.go b/runtime/runtime.go
index 5a3f654bd..4dff70831 100644
--- a/runtime/runtime.go
+++ b/runtime/runtime.go
@@ -48,6 +48,8 @@ type CreateOpts struct {
 	TaskOptions *types.Any
 	// Runtime to use
 	Runtime string
+	// ExternalResources for the task
+	ExternalResources *types.Any
 }
 
 // Exit information for a process
diff --git a/runtime/typeurl.go b/runtime/typeurl.go
index eb54e250f..dd26b2d31 100644
--- a/runtime/typeurl.go
+++ b/runtime/typeurl.go
@@ -19,6 +19,7 @@ package runtime
 import (
 	"strconv"
 
+	"github.com/containerd/containerd/external"
 	"github.com/containerd/typeurl"
 	specs "github.com/opencontainers/runtime-spec/specs-go"
 )
@@ -31,4 +32,5 @@ func init() {
 	typeurl.Register(&specs.Process{}, prefix, "opencontainers/runtime-spec", major, "Process")
 	typeurl.Register(&specs.LinuxResources{}, prefix, "opencontainers/runtime-spec", major, "LinuxResources")
 	typeurl.Register(&specs.WindowsResources{}, prefix, "opencontainers/runtime-spec", major, "WindowsResources")
+	typeurl.Register(&external.ResourcesInfo{}, prefix, "containerd/containerd", "ExternalResources")
 }
diff --git a/runtime/v2/manager.go b/runtime/v2/manager.go
index 085d77b51..6c59352e6 100644
--- a/runtime/v2/manager.go
+++ b/runtime/v2/manager.go
@@ -21,10 +21,13 @@ import (
 	"fmt"
 	"io/ioutil"
 	"os"
+	"os/exec"
+	"path"
 	"path/filepath"
 
 	"github.com/containerd/containerd/containers"
 	"github.com/containerd/containerd/events/exchange"
+	"github.com/containerd/containerd/external"
 	"github.com/containerd/containerd/log"
 	"github.com/containerd/containerd/metadata"
 	"github.com/containerd/containerd/mount"
@@ -33,7 +36,10 @@ import (
 	"github.com/containerd/containerd/platforms"
 	"github.com/containerd/containerd/plugin"
 	"github.com/containerd/containerd/runtime"
+	ptypes "github.com/gogo/protobuf/types"
 	ocispec "github.com/opencontainers/image-spec/specs-go/v1"
+	"github.com/opencontainers/runtime-spec/specs-go"
+	"github.com/pkg/errors"
 )
 
 // Config for the v2 runtime
@@ -125,6 +131,12 @@ func (m *TaskManager) Create(ctx context.Context, id string, opts runtime.Create
 	if err != nil {
 		return nil, err
 	}
+	if opts.ExternalResources != nil {
+		// try to mount external rootfs to bundle's rootfs
+		if err = populateRootfsWithExternal(bundle.Path, opts.ExternalResources); err != nil {
+			return nil, errors.Wrap(err, "failed to mount external rootfs")
+		}
+	}
 	defer func() {
 		if err != nil {
 			bundle.Delete()
@@ -318,3 +330,20 @@ func parsePlatforms(platformStr []string) ([]ocispec.Platform, error) {
 	}
 	return p, nil
 }
+
+func populateRootfsWithExternal(bundle string, externalResources *ptypes.Any) error {
+	er, err := external.Parse(externalResources)
+	if err != nil {
+		return err
+	}
+	namespaces := er.Namespaces
+	info, exists := namespaces[specs.MountNamespace]
+	if !exists {
+		return nil
+	}
+	rootfs := path.Join(bundle, "rootfs")
+	externalRootfs := path.Join(info.Info.(string), "rootfs")
+	// mount the external rootfs on rootfs
+	cmd := exec.Command("nsenter", "--mount="+info.Path, "mount", "-R", externalRootfs, rootfs)
+	return cmd.Run()
+}
diff --git a/runtime/v2/runc/container.go b/runtime/v2/runc/container.go
index 27d434a29..cc63ec15f 100644
--- a/runtime/v2/runc/container.go
+++ b/runtime/v2/runc/container.go
@@ -30,6 +30,7 @@ import (
 	cgroupsv2 "github.com/containerd/cgroups/v2"
 	"github.com/containerd/console"
 	"github.com/containerd/containerd/errdefs"
+	"github.com/containerd/containerd/external"
 	"github.com/containerd/containerd/mount"
 	"github.com/containerd/containerd/namespaces"
 	"github.com/containerd/containerd/pkg/process"
@@ -47,6 +48,10 @@ func NewContainer(ctx context.Context, platform stdio.Platform, r *task.CreateTa
 	if err != nil {
 		return nil, errors.Wrap(err, "create namespace")
 	}
+	er, err := external.Parse(r.ExternalResources)
+	if err != nil {
+		return nil, errors.Wrap(err, "parse external namspaces")
+	}
 
 	var opts options.Options
 	if r.Options != nil {
@@ -131,11 +136,12 @@ func NewContainer(ctx context.Context, platform stdio.Platform, r *task.CreateTa
 		return nil, errdefs.ToGRPC(err)
 	}
 	container := &Container{
-		ID:              r.ID,
-		Bundle:          r.Bundle,
-		process:         p,
-		processes:       make(map[string]process.Process),
-		reservedProcess: make(map[string]struct{}),
+		ID:                r.ID,
+		Bundle:            r.Bundle,
+		process:           p,
+		processes:         make(map[string]process.Process),
+		reservedProcess:   make(map[string]struct{}),
+		ExternalResources: er,
 	}
 	pid := p.Pid()
 	if pid > 0 {
@@ -241,6 +247,8 @@ type Container struct {
 	ID string
 	// Bundle path
 	Bundle string
+	// ExternalResources
+	ExternalResources *external.ResourcesInfo
 
 	// cgroup is either cgroups.Cgroup or *cgroupsv2.Manager
 	cgroup          interface{}
diff --git a/runtime/v2/runc/v2/service.go b/runtime/v2/runc/v2/service.go
index d3ea1e8ff..df5b783f0 100644
--- a/runtime/v2/runc/v2/service.go
+++ b/runtime/v2/runc/v2/service.go
@@ -24,17 +24,22 @@ import (
 	"io/ioutil"
 	"os"
 	"os/exec"
+	"path"
 	"path/filepath"
 	"strings"
 	"sync"
 	"syscall"
 	"time"
 
+	cermclient "github.com/YLonely/cer-manager/client"
+	"github.com/opencontainers/runtime-spec/specs-go"
+
 	"github.com/containerd/cgroups"
 	cgroupsv2 "github.com/containerd/cgroups/v2"
 	eventstypes "github.com/containerd/containerd/api/events"
 	"github.com/containerd/containerd/api/types/task"
 	"github.com/containerd/containerd/errdefs"
+	"github.com/containerd/containerd/external"
 	"github.com/containerd/containerd/mount"
 	"github.com/containerd/containerd/namespaces"
 	"github.com/containerd/containerd/pkg/oom"
@@ -715,6 +720,35 @@ func (s *service) checkProcesses(e runcC.Exit) {
 		if !container.HasPid(e.Pid) {
 			continue
 		}
+		// return external namespaces
+		if container.ExternalResources != nil {
+			client, err := cermclient.Default()
+			if err != nil {
+				logrus.WithError(err).Warn("failed to create client of external namespaces")
+			} else {
+				defer client.Close()
+				for _, ns := range []specs.LinuxNamespaceType{specs.IPCNamespace, specs.MountNamespace, specs.UTSNamespace} {
+					if info, exists := container.ExternalResources.Namespaces[ns]; exists {
+						if ns == specs.MountNamespace {
+							if err = depopulateRootfsOfExternal(container.Bundle, info.Path); err != nil {
+								logrus.WithError(err).Warnf("failed to depopulate rootfs %s", container.Bundle)
+							}
+						}
+						if err = external.PutNamespace(client, ns, info.ID); err != nil {
+							logrus.WithError(err).Warnf("failed to return namespace of type %s and id %d", ns, info.ID)
+						}
+					}
+				}
+				if container.ExternalResources.Checkpoint != nil {
+					if err = external.PutCheckpoint(client,
+						container.ExternalResources.Checkpoint.Namespace,
+						container.ExternalResources.Checkpoint.Name,
+					); err != nil {
+						logrus.WithError(err).Warnf("failed to return checkpoint %q", container.ExternalResources.Checkpoint.Name)
+					}
+				}
+			}
+		}
 
 		for _, p := range container.All() {
 			if p.Pid() != e.Pid {
@@ -800,3 +834,9 @@ func (s *service) initPlatform() error {
 	s.platform = p
 	return nil
 }
+
+func depopulateRootfsOfExternal(bundle, mountNamespacePath string) error {
+	rootfs := path.Join(bundle, "rootfs")
+	cmd := exec.Command("nsenter", "--mount="+mountNamespacePath, "umount", "-l", rootfs)
+	return cmd.Run()
+}
diff --git a/runtime/v2/shim.go b/runtime/v2/shim.go
index 8c1a72653..37ca26f1f 100644
--- a/runtime/v2/shim.go
+++ b/runtime/v2/shim.go
@@ -268,14 +268,15 @@ func (s *shim) Create(ctx context.Context, opts runtime.CreateOpts) (runtime.Tas
 		topts = opts.RuntimeOptions
 	}
 	request := &task.CreateTaskRequest{
-		ID:         s.ID(),
-		Bundle:     s.bundle.Path,
-		Stdin:      opts.IO.Stdin,
-		Stdout:     opts.IO.Stdout,
-		Stderr:     opts.IO.Stderr,
-		Terminal:   opts.IO.Terminal,
-		Checkpoint: opts.Checkpoint,
-		Options:    topts,
+		ID:                s.ID(),
+		Bundle:            s.bundle.Path,
+		Stdin:             opts.IO.Stdin,
+		Stdout:            opts.IO.Stdout,
+		Stderr:            opts.IO.Stderr,
+		Terminal:          opts.IO.Terminal,
+		Checkpoint:        opts.Checkpoint,
+		Options:           topts,
+		ExternalResources: opts.ExternalResources,
 	}
 	for _, m := range opts.Rootfs {
 		request.Rootfs = append(request.Rootfs, &types.Mount{
diff --git a/runtime/v2/task/shim.pb.go b/runtime/v2/task/shim.pb.go
index 3cf11d8e3..e88f586d4 100644
--- a/runtime/v2/task/shim.pb.go
+++ b/runtime/v2/task/shim.pb.go
@@ -43,6 +43,7 @@ type CreateTaskRequest struct {
 	Checkpoint           string         `protobuf:"bytes,8,opt,name=checkpoint,proto3" json:"checkpoint,omitempty"`
 	ParentCheckpoint     string         `protobuf:"bytes,9,opt,name=parent_checkpoint,json=parentCheckpoint,proto3" json:"parent_checkpoint,omitempty"`
 	Options              *types1.Any    `protobuf:"bytes,10,opt,name=options,proto3" json:"options,omitempty"`
+	ExternalResources    *types1.Any    `protobuf:"bytes,11,opt,name=external_resources,json=externalResources,proto3" json:"external_resources,omitempty"`
 	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
 	XXX_unrecognized     []byte         `json:"-"`
 	XXX_sizecache        int32          `json:"-"`
@@ -1125,85 +1126,87 @@ func init() {
 }
 
 var fileDescriptor_9202ee34bc3ad8ca = []byte{
-	// 1246 bytes of a gzipped FileDescriptorProto
-	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x58, 0x5d, 0x6f, 0x1b, 0x45,
-	0x17, 0xee, 0xfa, 0x63, 0x6d, 0x1f, 0xd7, 0x69, 0x3a, 0x6f, 0x9a, 0x77, 0xeb, 0x4a, 0xb6, 0xbb,
-	0xa5, 0xc1, 0x80, 0x64, 0x0b, 0x57, 0x70, 0x41, 0x24, 0x50, 0xbe, 0xa8, 0x4c, 0x0b, 0x89, 0xb6,
-	0x45, 0x45, 0xdc, 0x58, 0x1b, 0xef, 0xc4, 0x5e, 0xc5, 0xde, 0x59, 0x76, 0x66, 0xf3, 0x81, 0x84,
-	0xc4, 0x15, 0x17, 0x5c, 0xf1, 0xb3, 0x72, 0x89, 0xc4, 0x0d, 0x37, 0x04, 0xea, 0x7f, 0xc0, 0x3f,
-	0x40, 0xf3, 0xe1, 0x78, 0xed, 0xec, 0xda, 0x49, 0xe5, 0x9b, 0x68, 0xce, 0xce, 0x33, 0x67, 0xe6,
-	0x9c, 0x79, 0xce, 0x73, 0x26, 0x86, 0xcd, 0x9e, 0xcb, 0xfa, 0xe1, 0x61, 0xa3, 0x4b, 0x86, 0xcd,
-	0x2e, 0xf1, 0x98, 0xed, 0x7a, 0x38, 0x70, 0xa2, 0xc3, 0x20, 0xf4, 0x98, 0x3b, 0xc4, 0xcd, 0x93,
-	0x56, 0x93, 0xd9, 0xf4, 0xb8, 0x49, 0xfb, 0xee, 0xb0, 0xe1, 0x07, 0x84, 0x11, 0x84, 0x26, 0xb0,
-	0x06, 0x9f, 0x6b, 0x9c, 0xb4, 0xca, 0x0f, 0x7b, 0x84, 0xf4, 0x06, 0xb8, 0x29, 0x10, 0x87, 0xe1,
-	0x51, 0xd3, 0xf6, 0xce, 0x25, 0xbc, 0xfc, 0x68, 0x76, 0x0a, 0x0f, 0x7d, 0x36, 0x9e, 0x5c, 0xeb,
-	0x91, 0x1e, 0x11, 0xc3, 0x26, 0x1f, 0xa9, 0xaf, 0xd5, 0xd9, 0x25, 0xfc, 0x28, 0x94, 0xd9, 0x43,
-	0x5f, 0x01, 0x3e, 0x5d, 0x78, 0x7e, 0xdb, 0x77, 0x9b, 0xec, 0xdc, 0xc7, 0xb4, 0x39, 0x24, 0xa1,
-	0xc7, 0xd4, 0xba, 0xcf, 0x6e, 0xb1, 0x4e, 0x84, 0x2d, 0xe2, 0x13, 0x6b, 0xcd, 0x3f, 0x52, 0x70,
-	0x7f, 0x27, 0xc0, 0x36, 0xc3, 0xaf, 0x6d, 0x7a, 0x6c, 0xe1, 0x1f, 0x42, 0x4c, 0x19, 0x5a, 0x87,
-	0x94, 0xeb, 0x18, 0x5a, 0x4d, 0xab, 0x17, 0xb6, 0xf5, 0xd1, 0x65, 0x35, 0xd5, 0xde, 0xb5, 0x52,
-	0xae, 0x83, 0xd6, 0x41, 0x3f, 0x0c, 0x3d, 0x67, 0x80, 0x8d, 0x14, 0x9f, 0xb3, 0x94, 0x85, 0x9a,
-	0xa0, 0x07, 0x84, 0xb0, 0x23, 0x6a, 0xa4, 0x6b, 0xe9, 0x7a, 0xb1, 0xf5, 0xff, 0x46, 0x34, 0x9b,
-	0x7c, 0xe3, 0xc6, 0xd7, 0xfc, 0xc0, 0x96, 0x82, 0xa1, 0x32, 0xe4, 0x19, 0x0e, 0x86, 0xae, 0x67,
-	0x0f, 0x8c, 0x4c, 0x4d, 0xab, 0xe7, 0xad, 0x2b, 0x1b, 0xad, 0x41, 0x96, 0x32, 0xc7, 0xf5, 0x8c,
-	0xac, 0xd8, 0x43, 0x1a, 0x7c, 0x6b, 0xca, 0x1c, 0x12, 0x32, 0x43, 0x97, 0x5b, 0x4b, 0x4b, 0x7d,
-	0xc7, 0x41, 0x60, 0xe4, 0xae, 0xbe, 0xe3, 0x20, 0x40, 0x15, 0x80, 0x6e, 0x1f, 0x77, 0x8f, 0x7d,
-	0xe2, 0x7a, 0xcc, 0xc8, 0x8b, 0xb9, 0xc8, 0x17, 0xf4, 0x11, 0xdc, 0xf7, 0xed, 0x00, 0x7b, 0xac,
-	0x13, 0x81, 0x15, 0x04, 0x6c, 0x55, 0x4e, 0xec, 0x4c, 0xc0, 0x0d, 0xc8, 0x11, 0x9f, 0xb9, 0xc4,
-	0xa3, 0x06, 0xd4, 0xb4, 0x7a, 0xb1, 0xb5, 0xd6, 0x90, 0x97, 0xd9, 0x18, 0x5f, 0x66, 0x63, 0xcb,
-	0x3b, 0xb7, 0xc6, 0x20, 0x73, 0x03, 0x50, 0x34, 0xa9, 0xd4, 0x27, 0x1e, 0xc5, 0x68, 0x15, 0xd2,
-	0xbe, 0x4a, 0x6b, 0xc9, 0xe2, 0x43, 0xf3, 0x25, 0x94, 0x76, 0xf1, 0x00, 0x33, 0xbc, 0x28, 0xf1,
-	0x4f, 0x20, 0x87, 0xcf, 0x70, 0xb7, 0xe3, 0x3a, 0x32, 0xf3, 0xdb, 0x30, 0xba, 0xac, 0xea, 0x7b,
-	0x67, 0xb8, 0xdb, 0xde, 0xb5, 0x74, 0x3e, 0xd5, 0x76, 0xcc, 0x5f, 0x34, 0x58, 0x19, 0xbb, 0x4b,
-	0xda, 0x12, 0x55, 0xa1, 0x88, 0xcf, 0x5c, 0xd6, 0xa1, 0xcc, 0x66, 0x21, 0x15, 0xde, 0x4a, 0x16,
-	0xf0, 0x4f, 0xaf, 0xc4, 0x17, 0xb4, 0x05, 0x05, 0x6e, 0x61, 0xa7, 0x63, 0x33, 0x23, 0x2d, 0xa2,
-	0x2d, 0x5f, 0x8b, 0xf6, 0xf5, 0x98, 0xba, 0xdb, 0xf9, 0x8b, 0xcb, 0xea, 0x9d, 0xdf, 0xfe, 0xae,
-	0x6a, 0x56, 0x5e, 0x2e, 0xdb, 0x62, 0xe6, 0x5f, 0x1a, 0x20, 0x7e, 0xb6, 0x83, 0x80, 0x74, 0x31,
-	0xa5, 0xcb, 0x08, 0x6e, 0x8a, 0x31, 0xe9, 0x24, 0xc6, 0x64, 0xe2, 0x19, 0x93, 0x4d, 0x60, 0x8c,
-	0x3e, 0xc5, 0x98, 0x3a, 0x64, 0xa8, 0x8f, 0xbb, 0x82, 0x47, 0x49, 0x37, 0x2c, 0x10, 0xe6, 0x03,
-	0xf8, 0xdf, 0x54, 0x78, 0x32, 0xd9, 0xe6, 0x4f, 0xb0, 0x6a, 0x61, 0xea, 0xfe, 0x88, 0x0f, 0xd8,
-	0xf9, 0x52, 0x62, 0x5e, 0x83, 0xec, 0xa9, 0xeb, 0xb0, 0xbe, 0x08, 0xb8, 0x64, 0x49, 0x83, 0x9f,
-	0xbf, 0x8f, 0xdd, 0x5e, 0x9f, 0x89, 0x70, 0x4b, 0x96, 0xb2, 0xcc, 0x17, 0x70, 0x97, 0x5f, 0xe1,
-	0x72, 0xb8, 0xf4, 0x6f, 0x0a, 0x4a, 0xca, 0x9b, 0xa2, 0xd2, 0x6d, 0x35, 0x41, 0x51, 0x2f, 0x3d,
-	0xa1, 0xde, 0x33, 0x9e, 0x78, 0xc1, 0x3a, 0x7e, 0xf0, 0x95, 0xd6, 0xa3, 0xa8, 0x4a, 0x9c, 0x7c,
-	0xac, 0x84, 0x42, 0xd2, 0xd0, 0x52, 0xd0, 0x25, 0xa9, 0x41, 0x94, 0x3d, 0xf9, 0x19, 0xf6, 0xcc,
-	0x54, 0x44, 0x61, 0x7e, 0x45, 0xc0, 0xbb, 0x54, 0x44, 0x34, 0xe7, 0xc5, 0xc4, 0x9c, 0x33, 0x28,
-	0xbe, 0x70, 0x07, 0x83, 0xa5, 0x50, 0x87, 0x27, 0xc2, 0xed, 0x8d, 0x8b, 0xa5, 0x64, 0x29, 0x8b,
-	0xdf, 0x8a, 0x3d, 0x18, 0x6b, 0x2e, 0x1f, 0x9a, 0x5d, 0x58, 0xd9, 0x19, 0x10, 0x8a, 0xdb, 0xfb,
-	0xcb, 0xe2, 0xac, 0xbc, 0x2f, 0x59, 0xa4, 0xd2, 0x30, 0x9f, 0x42, 0xf1, 0xc0, 0x75, 0x16, 0x29,
-	0x81, 0xf9, 0x0d, 0xdc, 0x95, 0x30, 0xc5, 0xb9, 0xcf, 0xa1, 0xe0, 0xcb, 0x22, 0xc3, 0xd4, 0xd0,
-	0x44, 0x6b, 0xa9, 0xc5, 0x92, 0x46, 0x95, 0x62, 0xdb, 0x3b, 0x22, 0xd6, 0x64, 0x89, 0x49, 0xe1,
-	0xc1, 0x44, 0xc5, 0x6f, 0xd2, 0xe0, 0x10, 0x64, 0x7c, 0x9b, 0xf5, 0x15, 0x95, 0xc5, 0x38, 0x2a,
-	0xfe, 0xe9, 0x9b, 0x88, 0x7f, 0x07, 0xee, 0x7f, 0xeb, 0x3b, 0x37, 0xec, 0xa8, 0x2d, 0x28, 0x04,
-	0x98, 0x92, 0x30, 0xe8, 0x62, 0x29, 0xc6, 0x49, 0xee, 0x27, 0x30, 0x55, 0xe8, 0x01, 0x5b, 0x4a,
-	0xa1, 0x3f, 0x16, 0x75, 0xce, 0x9d, 0x25, 0x76, 0xa9, 0xaf, 0xa0, 0xf8, 0xc6, 0x76, 0x97, 0xb3,
-	0x5d, 0x00, 0x77, 0xa5, 0x2f, 0xb5, 0xdb, 0x4c, 0xf1, 0x69, 0xf3, 0x8b, 0x2f, 0xf5, 0x4e, 0xed,
-	0x68, 0x43, 0x0a, 0xe3, 0x42, 0xf6, 0x6d, 0x4a, 0xc9, 0x9b, 0xd0, 0xef, 0x43, 0xce, 0x65, 0x9b,
-	0xc9, 0x63, 0x25, 0x5d, 0x8c, 0x84, 0x98, 0x75, 0x58, 0xd9, 0x21, 0x9e, 0x87, 0xbb, 0x8b, 0xf2,
-	0x64, 0xda, 0x70, 0xef, 0x0a, 0xa9, 0x36, 0x7a, 0x08, 0x79, 0xfe, 0x14, 0xed, 0x4c, 0x12, 0x9f,
-	0xe3, 0xf6, 0x81, 0xeb, 0xf0, 0x29, 0xfe, 0x5c, 0x13, 0x53, 0xb2, 0x59, 0xe7, 0xb8, 0xcd, 0xa7,
-	0x0c, 0xc8, 0x9d, 0xe0, 0x80, 0xba, 0x44, 0x16, 0x5b, 0xc1, 0x1a, 0x9b, 0xe6, 0x26, 0xdc, 0x7b,
-	0xd5, 0x0f, 0x99, 0x43, 0x4e, 0xbd, 0x45, 0xb7, 0xb6, 0x0a, 0x69, 0x8f, 0x9c, 0x0a, 0xd7, 0x79,
-	0x8b, 0x0f, 0x79, 0xba, 0x0e, 0xec, 0x90, 0x2e, 0xea, 0x23, 0xe6, 0xfb, 0x50, 0xb2, 0x30, 0x0d,
-	0x87, 0x8b, 0x80, 0xad, 0x5f, 0x01, 0x32, 0xbc, 0x16, 0xd0, 0x4b, 0xc8, 0x8a, 0x9e, 0x82, 0xa6,
-	0x8a, 0x58, 0xbd, 0xb6, 0x1b, 0xd1, 0xe6, 0x55, 0x7e, 0x3c, 0x07, 0xa1, 0x92, 0xf6, 0x06, 0x74,
-	0xf9, 0xc8, 0x42, 0x4f, 0xe3, 0xc0, 0xd7, 0x5e, 0xb5, 0xe5, 0x8d, 0x45, 0x30, 0xe5, 0x58, 0x1e,
-	0x33, 0x60, 0x89, 0xc7, 0xbc, 0x2a, 0xbd, 0xc4, 0x63, 0x46, 0xea, 0x69, 0x1f, 0x74, 0xf9, 0x28,
-	0x43, 0xb1, 0xe0, 0xa9, 0xf7, 0x5f, 0xd9, 0x9c, 0x07, 0x51, 0x0e, 0xdb, 0x90, 0xe1, 0x22, 0x89,
-	0xaa, 0x71, 0xd8, 0x88, 0xca, 0x96, 0x6b, 0xc9, 0x00, 0xe5, 0x6a, 0x0b, 0xb2, 0xe2, 0xaa, 0xe3,
-	0x23, 0x8d, 0xb2, 0xa0, 0xbc, 0x7e, 0x8d, 0xfc, 0x7b, 0xfc, 0x3f, 0x1e, 0xb4, 0x03, 0xba, 0x64,
-	0x41, 0x7c, 0x78, 0x53, 0x0c, 0x49, 0x74, 0xb2, 0x0f, 0x10, 0x79, 0x6d, 0x7f, 0x10, 0x7b, 0x4f,
-	0x71, 0x3a, 0x9e, 0xe8, 0xf0, 0x0b, 0xc8, 0xf0, 0x56, 0x1a, 0x9f, 0xa3, 0x48, 0x93, 0x4d, 0x74,
-	0xf0, 0x25, 0x64, 0xb8, 0x72, 0xa1, 0x58, 0xce, 0x5c, 0x7f, 0xdb, 0x26, 0xfa, 0x69, 0x43, 0xe1,
-	0xea, 0x4d, 0x88, 0xde, 0x4b, 0xc8, 0xd0, 0xd4, 0x93, 0x31, 0xd1, 0xd5, 0x1e, 0xe4, 0x54, 0xa3,
-	0x46, 0xb1, 0x34, 0x99, 0xee, 0xe2, 0x89, 0x6e, 0x9e, 0x83, 0x2e, 0xdb, 0x53, 0x7c, 0xd9, 0x5c,
-	0x6b, 0x5d, 0x73, 0x42, 0xcb, 0x70, 0x29, 0x8f, 0xcf, 0x71, 0xa4, 0x61, 0xc4, 0xf3, 0x70, 0xaa,
-	0x0b, 0x28, 0x61, 0xa0, 0xc9, 0xc2, 0x40, 0x17, 0x0a, 0xc3, 0x84, 0xd5, 0x16, 0xe4, 0x94, 0xc0,
-	0x26, 0x24, 0x6a, 0x4a, 0xa7, 0xcb, 0x4f, 0xe6, 0x62, 0x94, 0xcf, 0xe7, 0x90, 0x1f, 0x2b, 0x2a,
-	0x8a, 0x5d, 0x30, 0xa3, 0xb7, 0x49, 0x59, 0xdb, 0xde, 0xbf, 0x78, 0x5b, 0xb9, 0xf3, 0xe7, 0xdb,
-	0xca, 0x9d, 0x9f, 0x47, 0x15, 0xed, 0x62, 0x54, 0xd1, 0x7e, 0x1f, 0x55, 0xb4, 0x7f, 0x46, 0x15,
-	0xed, 0xfb, 0x4f, 0x6e, 0xfb, 0xf3, 0xc5, 0x26, 0xff, 0xf3, 0x5d, 0xea, 0x50, 0x17, 0x5b, 0x3c,
-	0xfb, 0x2f, 0x00, 0x00, 0xff, 0xff, 0x19, 0x17, 0x87, 0x57, 0x00, 0x11, 0x00, 0x00,
+	// 1268 bytes of a gzipped FileDescriptorProto
+	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x58, 0x5b, 0x6f, 0x1b, 0xc5,
+	0x17, 0xef, 0xfa, 0xb2, 0xb6, 0x8f, 0xeb, 0x34, 0x99, 0x7f, 0xda, 0xff, 0xd6, 0x95, 0x6c, 0x77,
+	0x4b, 0x8b, 0x01, 0xc9, 0x16, 0xae, 0xe0, 0x81, 0x48, 0xa0, 0xc4, 0x0d, 0x95, 0x69, 0x21, 0xd1,
+	0xb6, 0xa8, 0x88, 0x17, 0x6b, 0xe3, 0x9d, 0xd8, 0xab, 0xd8, 0x3b, 0xcb, 0xce, 0x6c, 0x2e, 0x48,
+	0x48, 0x3c, 0xf1, 0xc0, 0x13, 0x8f, 0x7c, 0xa4, 0x3c, 0xf2, 0xc8, 0x0b, 0x81, 0xfa, 0x1b, 0xf0,
+	0x0d, 0xd0, 0x5c, 0x1c, 0xaf, 0x9d, 0x5d, 0x3b, 0xa9, 0xfc, 0x12, 0xcd, 0xd9, 0xf9, 0xcd, 0x99,
+	0x39, 0xe7, 0xfc, 0xce, 0x25, 0x86, 0xad, 0xbe, 0xcb, 0x06, 0xe1, 0x41, 0xa3, 0x47, 0x46, 0xcd,
+	0x1e, 0xf1, 0x98, 0xed, 0x7a, 0x38, 0x70, 0xa2, 0xcb, 0x20, 0xf4, 0x98, 0x3b, 0xc2, 0xcd, 0xe3,
+	0x56, 0x93, 0xd9, 0xf4, 0xa8, 0x49, 0x07, 0xee, 0xa8, 0xe1, 0x07, 0x84, 0x11, 0x84, 0xa6, 0xb0,
+	0x06, 0xdf, 0x6b, 0x1c, 0xb7, 0xca, 0xf7, 0xfb, 0x84, 0xf4, 0x87, 0xb8, 0x29, 0x10, 0x07, 0xe1,
+	0x61, 0xd3, 0xf6, 0xce, 0x24, 0xbc, 0xfc, 0x60, 0x7e, 0x0b, 0x8f, 0x7c, 0x36, 0xd9, 0xdc, 0xec,
+	0x93, 0x3e, 0x11, 0xcb, 0x26, 0x5f, 0xa9, 0xaf, 0xd5, 0xf9, 0x23, 0xfc, 0x29, 0x94, 0xd9, 0x23,
+	0x5f, 0x01, 0x3e, 0x5d, 0xfa, 0x7e, 0xdb, 0x77, 0x9b, 0xec, 0xcc, 0xc7, 0xb4, 0x39, 0x22, 0xa1,
+	0xc7, 0xd4, 0xb9, 0xcf, 0x6e, 0x70, 0x4e, 0x98, 0x2d, 0xec, 0x13, 0x67, 0xcd, 0xdf, 0xd3, 0xb0,
+	0xd1, 0x0e, 0xb0, 0xcd, 0xf0, 0x6b, 0x9b, 0x1e, 0x59, 0xf8, 0x87, 0x10, 0x53, 0x86, 0xee, 0x41,
+	0xca, 0x75, 0x0c, 0xad, 0xa6, 0xd5, 0x0b, 0x3b, 0xfa, 0xf8, 0xa2, 0x9a, 0xea, 0x3c, 0xb3, 0x52,
+	0xae, 0x83, 0xee, 0x81, 0x7e, 0x10, 0x7a, 0xce, 0x10, 0x1b, 0x29, 0xbe, 0x67, 0x29, 0x09, 0x35,
+	0x41, 0x0f, 0x08, 0x61, 0x87, 0xd4, 0x48, 0xd7, 0xd2, 0xf5, 0x62, 0xeb, 0xff, 0x8d, 0xa8, 0x37,
+	0xf9, 0xc5, 0x8d, 0xaf, 0xf9, 0x83, 0x2d, 0x05, 0x43, 0x65, 0xc8, 0x33, 0x1c, 0x8c, 0x5c, 0xcf,
+	0x1e, 0x1a, 0x99, 0x9a, 0x56, 0xcf, 0x5b, 0x97, 0x32, 0xda, 0x84, 0x2c, 0x65, 0x8e, 0xeb, 0x19,
+	0x59, 0x71, 0x87, 0x14, 0xf8, 0xd5, 0x94, 0x39, 0x24, 0x64, 0x86, 0x2e, 0xaf, 0x96, 0x92, 0xfa,
+	0x8e, 0x83, 0xc0, 0xc8, 0x5d, 0x7e, 0xc7, 0x41, 0x80, 0x2a, 0x00, 0xbd, 0x01, 0xee, 0x1d, 0xf9,
+	0xc4, 0xf5, 0x98, 0x91, 0x17, 0x7b, 0x91, 0x2f, 0xe8, 0x23, 0xd8, 0xf0, 0xed, 0x00, 0x7b, 0xac,
+	0x1b, 0x81, 0x15, 0x04, 0x6c, 0x5d, 0x6e, 0xb4, 0xa7, 0xe0, 0x06, 0xe4, 0x88, 0xcf, 0x5c, 0xe2,
+	0x51, 0x03, 0x6a, 0x5a, 0xbd, 0xd8, 0xda, 0x6c, 0xc8, 0x60, 0x36, 0x26, 0xc1, 0x6c, 0x6c, 0x7b,
+	0x67, 0xd6, 0x04, 0x84, 0xda, 0x80, 0xf0, 0x29, 0xc3, 0x81, 0x67, 0x0f, 0xbb, 0x01, 0xa6, 0x24,
+	0x0c, 0x7a, 0x98, 0x1a, 0xc5, 0x05, 0x47, 0x37, 0x26, 0x78, 0x6b, 0x02, 0x37, 0x9f, 0x00, 0x8a,
+	0x46, 0x86, 0xfa, 0xc4, 0xa3, 0x18, 0xad, 0x43, 0xda, 0x57, 0xb1, 0x29, 0x59, 0x7c, 0x69, 0xbe,
+	0x84, 0xd2, 0x33, 0x3c, 0xc4, 0x0c, 0x2f, 0x8b, 0xde, 0x23, 0xc8, 0xe1, 0x53, 0xdc, 0xeb, 0xba,
+	0x8e, 0x0c, 0xdf, 0x0e, 0x8c, 0x2f, 0xaa, 0xfa, 0xee, 0x29, 0xee, 0x75, 0x9e, 0x59, 0x3a, 0xdf,
+	0xea, 0x38, 0xe6, 0x2f, 0x1a, 0xac, 0x4d, 0xd4, 0x25, 0x5d, 0x89, 0xaa, 0x50, 0xc4, 0xa7, 0x2e,
+	0xeb, 0x52, 0x66, 0xb3, 0x90, 0x0a, 0x6d, 0x25, 0x0b, 0xf8, 0xa7, 0x57, 0xe2, 0x0b, 0xda, 0x86,
+	0x02, 0x97, 0xb0, 0xd3, 0xb5, 0x99, 0x91, 0x16, 0x76, 0x97, 0xaf, 0xd8, 0xfd, 0x7a, 0xc2, 0xff,
+	0x9d, 0xfc, 0xf9, 0x45, 0xf5, 0xd6, 0x6f, 0x7f, 0x57, 0x35, 0x2b, 0x2f, 0x8f, 0x6d, 0x33, 0xf3,
+	0x2f, 0x0d, 0x10, 0x7f, 0xdb, 0x7e, 0x40, 0x7a, 0x98, 0xd2, 0x55, 0x18, 0x37, 0x43, 0xbb, 0x74,
+	0x12, 0xed, 0x32, 0xf1, 0xb4, 0xcb, 0x26, 0xd0, 0x4e, 0x9f, 0xa1, 0x5d, 0x1d, 0x32, 0xd4, 0xc7,
+	0x3d, 0x41, 0xc6, 0xa4, 0x58, 0x0b, 0x84, 0x79, 0x17, 0xfe, 0x37, 0x63, 0x9e, 0x74, 0xb6, 0xf9,
+	0x13, 0xac, 0x5b, 0x98, 0xba, 0x3f, 0xe2, 0x7d, 0x76, 0xb6, 0x12, 0x9b, 0x37, 0x21, 0x7b, 0xe2,
+	0x3a, 0x6c, 0x20, 0x0c, 0x2e, 0x59, 0x52, 0xe0, 0xef, 0x1f, 0x60, 0xb7, 0x3f, 0x60, 0xc2, 0xdc,
+	0x92, 0xa5, 0x24, 0xf3, 0x05, 0xdc, 0xe6, 0x21, 0x5c, 0x0d, 0x97, 0xfe, 0x4d, 0x41, 0x49, 0x69,
+	0x53, 0x54, 0xba, 0x69, 0x61, 0x51, 0xd4, 0x4b, 0x4f, 0xa9, 0xf7, 0x94, 0x3b, 0x5e, 0xb0, 0x8e,
+	0x3f, 0x7c, 0xad, 0xf5, 0x20, 0x5a, 0x6a, 0x8e, 0x3f, 0x56, 0xd5, 0x46, 0xd2, 0xd0, 0x52, 0xd0,
+	0x15, 0x95, 0x94, 0x28, 0x7b, 0xf2, 0x73, 0xec, 0x99, 0xcb, 0x88, 0xc2, 0xe2, 0x8c, 0x80, 0x77,
+	0xc9, 0x88, 0xa8, 0xcf, 0x8b, 0x89, 0x3e, 0x67, 0x50, 0x7c, 0xe1, 0x0e, 0x87, 0x2b, 0xa1, 0x0e,
+	0x77, 0x84, 0xdb, 0x9f, 0x24, 0x4b, 0xc9, 0x52, 0x12, 0x8f, 0x8a, 0x3d, 0x9c, 0x14, 0x6e, 0xbe,
+	0x34, 0x7b, 0xb0, 0xd6, 0x1e, 0x12, 0x8a, 0x3b, 0x7b, 0xab, 0xe2, 0xac, 0x8c, 0x97, 0x4c, 0x52,
+	0x29, 0x98, 0x8f, 0xa1, 0xb8, 0xef, 0x3a, 0xcb, 0x2a, 0x81, 0xf9, 0x0d, 0xdc, 0x96, 0x30, 0xc5,
+	0xb9, 0xcf, 0xa1, 0xe0, 0xcb, 0x24, 0xc3, 0xd4, 0xd0, 0x44, 0x7f, 0xaa, 0xc5, 0x92, 0x46, 0xa5,
+	0x62, 0xc7, 0x3b, 0x24, 0xd6, 0xf4, 0x88, 0x49, 0xe1, 0xee, 0xb4, 0x15, 0x5c, 0xa7, 0x4b, 0x22,
+	0xc8, 0xf8, 0x36, 0x1b, 0x28, 0x2a, 0x8b, 0x75, 0xb4, 0x83, 0xa4, 0xaf, 0xd1, 0x41, 0xcc, 0x2e,
+	0x6c, 0x7c, 0xeb, 0x3b, 0xd7, 0x6c, 0xcb, 0x2d, 0x28, 0x4c, 0xbb, 0x4c, 0x6a, 0x81, 0xfa, 0x29,
+	0x4c, 0x25, 0x7a, 0xc0, 0x56, 0x92, 0xe8, 0x0f, 0x45, 0x9e, 0x73, 0x65, 0x89, 0x5d, 0xea, 0x2b,
+	0x28, 0xbe, 0xb1, 0xdd, 0xd5, 0x5c, 0x17, 0xc0, 0x6d, 0xa9, 0x4b, 0xdd, 0x36, 0x97, 0x7c, 0xda,
+	0xe2, 0xe4, 0x4b, 0xbd, 0x53, 0x3b, 0x7a, 0x22, 0x0b, 0xe3, 0x52, 0xf6, 0x6d, 0xc9, 0x92, 0x37,
+	0xa5, 0xdf, 0x87, 0x9c, 0xcb, 0x36, 0x93, 0xcf, 0x4a, 0x0a, 0x8c, 0x84, 0x98, 0x75, 0x58, 0x6b,
+	0x13, 0xcf, 0xc3, 0xbd, 0x65, 0x7e, 0x32, 0x6d, 0xb8, 0x73, 0x89, 0x54, 0x17, 0xdd, 0x87, 0x3c,
+	0x9f, 0x67, 0xbb, 0x53, 0xc7, 0xe7, 0xb8, 0xbc, 0xef, 0x3a, 0x7c, 0x8b, 0xcf, 0x7c, 0x62, 0x4b,
+	0x36, 0xeb, 0x1c, 0x97, 0xf9, 0x96, 0x01, 0xb9, 0x63, 0x1c, 0x50, 0x97, 0xc8, 0x64, 0x2b, 0x58,
+	0x13, 0xd1, 0xdc, 0x82, 0x3b, 0xaf, 0x06, 0x21, 0x73, 0xc8, 0x89, 0xb7, 0x2c, 0x6a, 0xeb, 0x90,
+	0xf6, 0xc8, 0x89, 0x50, 0x9d, 0xb7, 0xf8, 0x92, 0xbb, 0x6b, 0xdf, 0x0e, 0xe9, 0xb2, 0x3e, 0x62,
+	0xbe, 0x0f, 0x25, 0x0b, 0xd3, 0x70, 0xb4, 0x0c, 0xd8, 0xfa, 0x15, 0x20, 0xc3, 0x73, 0x01, 0xbd,
+	0x84, 0xac, 0xe8, 0x29, 0x68, 0x26, 0x89, 0xd5, 0xc8, 0xde, 0x88, 0x36, 0xaf, 0xf2, 0xc3, 0x05,
+	0x08, 0xe5, 0xb4, 0x37, 0xa0, 0xcb, 0x21, 0x0b, 0x3d, 0x8e, 0x03, 0x5f, 0x19, 0x8d, 0xcb, 0x4f,
+	0x96, 0xc1, 0x94, 0x62, 0xf9, 0xcc, 0x80, 0x25, 0x3e, 0xf3, 0x32, 0xf5, 0x12, 0x9f, 0x19, 0xc9,
+	0xa7, 0x3d, 0xd0, 0xe5, 0x50, 0x86, 0x62, 0xc1, 0x33, 0xf3, 0x5f, 0xd9, 0x5c, 0x04, 0x51, 0x0a,
+	0x3b, 0x90, 0xe1, 0x45, 0x12, 0x55, 0xe3, 0xb0, 0x91, 0x2a, 0x5b, 0xae, 0x25, 0x03, 0x94, 0xaa,
+	0x6d, 0xc8, 0x8a, 0x50, 0xc7, 0x5b, 0x1a, 0x65, 0x41, 0xf9, 0xde, 0x15, 0xf2, 0xef, 0xf2, 0x7f,
+	0x9b, 0x50, 0x1b, 0x74, 0xc9, 0x82, 0x78, 0xf3, 0x66, 0x18, 0x92, 0xa8, 0x64, 0x0f, 0x20, 0x32,
+	0xb2, 0x7f, 0x10, 0x1b, 0xa7, 0xb8, 0x3a, 0x9e, 0xa8, 0xf0, 0x0b, 0xc8, 0xf0, 0x56, 0x1a, 0xef,
+	0xa3, 0x48, 0x93, 0x4d, 0x54, 0xf0, 0x25, 0x64, 0x78, 0xe5, 0x42, 0xb1, 0x9c, 0xb9, 0x3a, 0xdb,
+	0x26, 0xea, 0xe9, 0x40, 0xe1, 0x72, 0x26, 0x44, 0xef, 0x25, 0x78, 0x68, 0x66, 0x64, 0x4c, 0x54,
+	0xb5, 0x0b, 0x39, 0xd5, 0xa8, 0x51, 0x2c, 0x4d, 0x66, 0xbb, 0x78, 0xa2, 0x9a, 0xe7, 0xa0, 0xcb,
+	0xf6, 0x14, 0x9f, 0x36, 0x57, 0x5a, 0xd7, 0x02, 0xd3, 0x32, 0xbc, 0x94, 0xc7, 0xfb, 0x38, 0xd2,
+	0x30, 0xe2, 0x79, 0x38, 0xd3, 0x05, 0x54, 0x61, 0xa0, 0xc9, 0x85, 0x81, 0x2e, 0x2d, 0x0c, 0x53,
+	0x56, 0x5b, 0x90, 0x53, 0x05, 0x36, 0xc1, 0x51, 0x33, 0x75, 0xba, 0xfc, 0x68, 0x21, 0x46, 0xe9,
+	0x7c, 0x0e, 0xf9, 0x49, 0x45, 0x45, 0xb1, 0x07, 0xe6, 0xea, 0x6d, 0x92, 0xd7, 0x76, 0xf6, 0xce,
+	0xdf, 0x56, 0x6e, 0xfd, 0xf9, 0xb6, 0x72, 0xeb, 0xe7, 0x71, 0x45, 0x3b, 0x1f, 0x57, 0xb4, 0x3f,
+	0xc6, 0x15, 0xed, 0x9f, 0x71, 0x45, 0xfb, 0xfe, 0x93, 0x9b, 0xfe, 0x06, 0xb2, 0xc5, 0xff, 0x7c,
+	0x97, 0x3a, 0xd0, 0xc5, 0x15, 0x4f, 0xff, 0x0b, 0x00, 0x00, 0xff, 0xff, 0x0b, 0xea, 0x7d, 0x1d,
+	0x45, 0x11, 0x00, 0x00,
 }
 
 func (m *CreateTaskRequest) Marshal() (dAtA []byte, err error) {
@@ -1230,6 +1233,18 @@ func (m *CreateTaskRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
 		i -= len(m.XXX_unrecognized)
 		copy(dAtA[i:], m.XXX_unrecognized)
 	}
+	if m.ExternalResources != nil {
+		{
+			size, err := m.ExternalResources.MarshalToSizedBuffer(dAtA[:i])
+			if err != nil {
+				return 0, err
+			}
+			i -= size
+			i = encodeVarintShim(dAtA, i, uint64(size))
+		}
+		i--
+		dAtA[i] = 0x5a
+	}
 	if m.Options != nil {
 		{
 			size, err := m.Options.MarshalToSizedBuffer(dAtA[:i])
@@ -1415,12 +1430,12 @@ func (m *DeleteResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
 		i -= len(m.XXX_unrecognized)
 		copy(dAtA[i:], m.XXX_unrecognized)
 	}
-	n2, err2 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.ExitedAt, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.ExitedAt):])
-	if err2 != nil {
-		return 0, err2
+	n3, err3 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.ExitedAt, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.ExitedAt):])
+	if err3 != nil {
+		return 0, err3
 	}
-	i -= n2
-	i = encodeVarintShim(dAtA, i, uint64(n2))
+	i -= n3
+	i = encodeVarintShim(dAtA, i, uint64(n3))
 	i--
 	dAtA[i] = 0x1a
 	if m.ExitStatus != 0 {
@@ -1670,12 +1685,12 @@ func (m *StateResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
 		i--
 		dAtA[i] = 0x5a
 	}
-	n4, err4 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.ExitedAt, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.ExitedAt):])
-	if err4 != nil {
-		return 0, err4
+	n5, err5 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.ExitedAt, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.ExitedAt):])
+	if err5 != nil {
+		return 0, err5
 	}
-	i -= n4
-	i = encodeVarintShim(dAtA, i, uint64(n4))
+	i -= n5
+	i = encodeVarintShim(dAtA, i, uint64(n5))
 	i--
 	dAtA[i] = 0x52
 	if m.ExitStatus != 0 {
@@ -2160,12 +2175,12 @@ func (m *WaitResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
 		i -= len(m.XXX_unrecognized)
 		copy(dAtA[i:], m.XXX_unrecognized)
 	}
-	n7, err7 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.ExitedAt, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.ExitedAt):])
-	if err7 != nil {
-		return 0, err7
+	n8, err8 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.ExitedAt, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.ExitedAt):])
+	if err8 != nil {
+		return 0, err8
 	}
-	i -= n7
-	i = encodeVarintShim(dAtA, i, uint64(n7))
+	i -= n8
+	i = encodeVarintShim(dAtA, i, uint64(n8))
 	i--
 	dAtA[i] = 0x12
 	if m.ExitStatus != 0 {
@@ -2497,6 +2512,10 @@ func (m *CreateTaskRequest) Size() (n int) {
 		l = m.Options.Size()
 		n += 1 + l + sovShim(uint64(l))
 	}
+	if m.ExternalResources != nil {
+		l = m.ExternalResources.Size()
+		n += 1 + l + sovShim(uint64(l))
+	}
 	if m.XXX_unrecognized != nil {
 		n += len(m.XXX_unrecognized)
 	}
@@ -3051,6 +3070,7 @@ func (this *CreateTaskRequest) String() string {
 		`Checkpoint:` + fmt.Sprintf("%v", this.Checkpoint) + `,`,
 		`ParentCheckpoint:` + fmt.Sprintf("%v", this.ParentCheckpoint) + `,`,
 		`Options:` + strings.Replace(fmt.Sprintf("%v", this.Options), "Any", "types1.Any", 1) + `,`,
+		`ExternalResources:` + strings.Replace(fmt.Sprintf("%v", this.ExternalResources), "Any", "types1.Any", 1) + `,`,
 		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
 		`}`,
 	}, "")
@@ -4013,6 +4033,42 @@ func (m *CreateTaskRequest) Unmarshal(dAtA []byte) error {
 				return err
 			}
 			iNdEx = postIndex
+		case 11:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field ExternalResources", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowShim
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthShim
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthShim
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			if m.ExternalResources == nil {
+				m.ExternalResources = &types1.Any{}
+			}
+			if err := m.ExternalResources.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
 		default:
 			iNdEx = preIndex
 			skippy, err := skipShim(dAtA[iNdEx:])
diff --git a/runtime/v2/task/shim.proto b/runtime/v2/task/shim.proto
index d390462dc..a01c4e72e 100644
--- a/runtime/v2/task/shim.proto
+++ b/runtime/v2/task/shim.proto
@@ -46,6 +46,7 @@ message CreateTaskRequest {
 	string checkpoint = 8;
 	string parent_checkpoint = 9;
 	google.protobuf.Any options = 10;
+	google.protobuf.Any external_resources = 11;
 }
 
 message CreateTaskResponse {
diff --git a/services/tasks/local.go b/services/tasks/local.go
index 632bd5080..440edf3ae 100644
--- a/services/tasks/local.go
+++ b/services/tasks/local.go
@@ -27,6 +27,7 @@ import (
 	"strings"
 	"time"
 
+	cermclient "github.com/YLonely/cer-manager/client"
 	api "github.com/containerd/containerd/api/services/tasks/v1"
 	"github.com/containerd/containerd/api/types"
 	"github.com/containerd/containerd/api/types/task"
@@ -35,6 +36,7 @@ import (
 	"github.com/containerd/containerd/content"
 	"github.com/containerd/containerd/errdefs"
 	"github.com/containerd/containerd/events"
+	"github.com/containerd/containerd/external"
 	"github.com/containerd/containerd/filters"
 	"github.com/containerd/containerd/images"
 	"github.com/containerd/containerd/log"
@@ -49,6 +51,7 @@ import (
 	"github.com/containerd/containerd/services"
 	"github.com/containerd/typeurl"
 	ptypes "github.com/gogo/protobuf/types"
+	"github.com/google/crfs/stargz"
 	ocispec "github.com/opencontainers/image-spec/specs-go/v1"
 	"github.com/pkg/errors"
 	"google.golang.org/grpc"
@@ -147,29 +150,53 @@ func (l *local) Create(ctx context.Context, r *api.CreateTaskRequest, _ ...grpc.
 	if err != nil {
 		return nil, err
 	}
+	externalCheckpoint := false
+	var checkpointName, checkpointNamespace string
 	// jump get checkpointPath from checkpoint image
 	if checkpointPath == "" && r.Checkpoint != nil {
-		checkpointPath, err = ioutil.TempDir(os.Getenv("XDG_RUNTIME_DIR"), "ctrd-checkpoint")
-		if err != nil {
-			return nil, err
-		}
-		if r.Checkpoint.MediaType != images.MediaTypeContainerd1Checkpoint {
-			return nil, fmt.Errorf("unsupported checkpoint type %q", r.Checkpoint.MediaType)
-		}
-		reader, err := l.store.ReaderAt(ctx, ocispec.Descriptor{
-			MediaType:   r.Checkpoint.MediaType,
-			Digest:      r.Checkpoint.Digest,
-			Size:        r.Checkpoint.Size_,
-			Annotations: r.Checkpoint.Annotations,
-		})
-		if err != nil {
-			return nil, err
+		if r.Checkpoint.MediaType == "" {
+			externalCheckpoint = true
+			client, err := cermclient.Default()
+			if err != nil {
+				return nil, err
+			}
+			defer client.Close()
+			checkpointName = r.Checkpoint.Annotations["name"]
+			checkpointNamespace = r.Checkpoint.Annotations["namespace"]
+			checkpointPath, err = external.GetCheckpoint(client, checkpointNamespace, checkpointName)
+			if err != nil {
+				return nil, err
+			}
+		} else {
+			checkpointPath, err = ioutil.TempDir(os.Getenv("XDG_RUNTIME_DIR"), "ctrd-checkpoint")
+			if err != nil {
+				return nil, err
+			}
+			if r.Checkpoint.MediaType != images.MediaTypeContainerd1Checkpoint {
+				return nil, fmt.Errorf("unsupported checkpoint type %q", r.Checkpoint.MediaType)
+			}
+			reader, err := l.store.ReaderAt(ctx, ocispec.Descriptor{
+				MediaType:   r.Checkpoint.MediaType,
+				Digest:      r.Checkpoint.Digest,
+				Size:        r.Checkpoint.Size_,
+				Annotations: r.Checkpoint.Annotations,
+			})
+			if err != nil {
+				return nil, err
+			}
+			_, err = archive.Apply(ctx, checkpointPath, content.NewReader(reader))
+			reader.Close()
+			if err != nil {
+				return nil, err
+			}
 		}
-		_, err = archive.Apply(ctx, checkpointPath, content.NewReader(reader))
-		reader.Close()
-		if err != nil {
-			return nil, err
+	}
+	erAny := getExternalResourcesAny(container)
+	if externalCheckpoint {
+		if erAny == nil {
+			return nil, errors.New("container has emptry external resources")
 		}
+		erAny, err = setExternalCheckpoint(erAny, checkpointName, checkpointNamespace)
 	}
 	opts := runtime.CreateOpts{
 		Spec: container.Spec,
@@ -179,10 +206,11 @@ func (l *local) Create(ctx context.Context, r *api.CreateTaskRequest, _ ...grpc.
 			Stderr:   r.Stderr,
 			Terminal: r.Terminal,
 		},
-		Checkpoint:     checkpointPath,
-		Runtime:        container.Runtime.Name,
-		RuntimeOptions: container.Runtime.Options,
-		TaskOptions:    r.Options,
+		Checkpoint:        checkpointPath,
+		Runtime:           container.Runtime.Name,
+		RuntimeOptions:    container.Runtime.Options,
+		TaskOptions:       r.Options,
+		ExternalResources: erAny,
 	}
 	for _, m := range r.Rootfs {
 		opts.Rootfs = append(opts.Rootfs, mount.Mount{
@@ -529,7 +557,11 @@ func (l *local) Checkpoint(ctx context.Context, r *api.CheckpointTaskRequest, _
 	}
 	// write checkpoint to the content store
 	tar := archive.Diff(ctx, "", image)
-	cp, err := l.writeContent(ctx, images.MediaTypeContainerd1Checkpoint, image, tar)
+	mediaType := images.MediaTypeContainerd1Checkpoint
+	if r.CompressCheckpoint {
+		mediaType = images.MediaTypeContainerd1CheckpointStargz
+	}
+	cp, err := l.writeContent(ctx, mediaType, image, tar)
 	// close tar first after write
 	if err := tar.Close(); err != nil {
 		return nil, err
@@ -635,17 +667,36 @@ func getTasksMetrics(ctx context.Context, filter filters.Filter, tasks []runtime
 	}
 }
 
+type byteCounter struct {
+	count int64
+}
+
+func (bc *byteCounter) Write(b []byte) (int, error) {
+	bc.count += int64(len(b))
+	return len(b), nil
+}
+
 func (l *local) writeContent(ctx context.Context, mediaType, ref string, r io.Reader) (*types.Descriptor, error) {
 	writer, err := l.store.Writer(ctx, content.WithRef(ref), content.WithDescriptor(ocispec.Descriptor{MediaType: mediaType}))
 	if err != nil {
 		return nil, err
 	}
 	defer writer.Close()
-	size, err := io.Copy(writer, r)
+	var size int64
+	bc := &byteCounter{}
+	if strings.HasSuffix(mediaType, "stargz") {
+		compressed := stargz.NewWriter(io.MultiWriter(writer, bc))
+		compressed.ChunkSize = 1 << 19
+		compressed.AppendTar(r)
+		compressed.Close()
+		size = bc.count
+	} else {
+		size, err = io.Copy(writer, r)
+	}
 	if err != nil {
 		return nil, err
 	}
-	if err := writer.Commit(ctx, 0, ""); err != nil {
+	if err := writer.Commit(ctx, 0, ""); err != nil && !errdefs.IsAlreadyExists(err) {
 		return nil, err
 	}
 	return &types.Descriptor{
@@ -785,3 +836,49 @@ func checkRuntime(current, expected string) bool {
 	}
 	return true
 }
+
+func getExternalResourcesAny(c *containers.Container) *ptypes.Any {
+	if c.Extensions == nil {
+		return nil
+	}
+	var any ptypes.Any
+	var exists bool
+	any, exists = c.Extensions[external.ResourcesExtensionKey]
+	if !exists {
+		return nil
+	}
+	return &any
+}
+
+func parseExternalResources(any *ptypes.Any) (*external.ResourcesInfo, error) {
+	if any == nil {
+		return nil, nil
+	}
+	var i interface{}
+	var err error
+	i, err = typeurl.UnmarshalAny(any)
+	if err != nil {
+		return nil, err
+	}
+	ret, ok := i.(*external.ResourcesInfo)
+	if !ok {
+		return nil, errors.New("can't convert any to ExternalResources")
+	}
+	return ret, nil
+}
+
+func setExternalCheckpoint(any *ptypes.Any, name, namespace string) (*ptypes.Any, error) {
+	info, err := parseExternalResources(any)
+	if err != nil {
+		return nil, err
+	}
+	info.Checkpoint = &external.CheckpointInfo{
+		Name:      name,
+		Namespace: namespace,
+	}
+	newAny, err := typeurl.MarshalAny(info)
+	if err != nil {
+		return nil, err
+	}
+	return newAny, nil
+}
diff --git a/task_opts.go b/task_opts.go
index 07e094c7c..8a1f54853 100644
--- a/task_opts.go
+++ b/task_opts.go
@@ -48,8 +48,18 @@ func WithRootFS(mounts []mount.Mount) NewTaskOpts {
 // WithTaskCheckpoint allows a task to be created with live runtime and memory data from a
 // previous checkpoint. Additional software such as CRIU may be required to
 // restore a task from a checkpoint
-func WithTaskCheckpoint(im Image) NewTaskOpts {
+func WithTaskCheckpoint(im Image, useExternalCheckpoint bool) NewTaskOpts {
 	return func(ctx context.Context, c *Client, info *TaskInfo) error {
+		if useExternalCheckpoint {
+			// we store the name and the namespace of the checkpoint in descriptor
+			info.Checkpoint = &types.Descriptor{
+				Annotations: map[string]string{
+					"name":      im.Name(),
+					"namespace": c.defaultns,
+				},
+			}
+			return nil
+		}
 		desc := im.Target()
 		id := desc.Digest
 		index, err := decodeIndex(ctx, c.ContentStore(), desc)
@@ -57,7 +67,8 @@ func WithTaskCheckpoint(im Image) NewTaskOpts {
 			return err
 		}
 		for _, m := range index.Manifests {
-			if m.MediaType == images.MediaTypeContainerd1Checkpoint {
+			if m.MediaType == images.MediaTypeContainerd1Checkpoint ||
+				m.MediaType == images.MediaTypeContainerd1CheckpointStargz {
 				info.Checkpoint = &types.Descriptor{
 					MediaType:   m.MediaType,
 					Size_:       m.Size,
